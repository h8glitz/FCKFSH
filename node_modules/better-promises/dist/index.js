var V = Object.defineProperty;
var Y = (n, r, e) => r in n ? V(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e;
var y = (n, r, e) => Y(n, typeof r != "symbol" ? r + "" : r, e);
function $(n) {
  return (r) => r instanceof n;
}
function B(n, r) {
  r || (r = []);
  class e extends Error {
    constructor(...o) {
      const s = typeof r == "function" ? r(...o) : typeof r == "string" ? [r] : r || [];
      super(...s), this.name = n;
    }
  }
  return Object.defineProperty(e, "name", { value: n }), [e, $(e)];
}
const [k, H] = B("CancelledError", "Promise was canceled"), [q, J] = B(
  "TimeoutError",
  (n, r) => [`Timeout reached: ${n}ms`, { cause: r }]
), D = Symbol("Resolved");
function S(n) {
  return Array.isArray(n) && n[0] === D;
}
function z(n) {
  return [D, n];
}
function x(n, r) {
  return n.reject = r.reject, n.abort = r.abort, n;
}
class w extends Promise {
  constructor(e, c) {
    let o, s;
    super((a, i) => {
      let d, u;
      typeof e == "function" ? (d = e, u = c) : u = e;
      const b = [], j = (t) => (...h) => {
        const p = t(...h);
        return b.forEach((P) => P()), p;
      }, g = new AbortController(), { signal: l } = g;
      s = (t) => {
        !l.aborted && g.abort(t);
      };
      const v = () => l.reason, E = (t) => {
        const h = () => {
          t(v());
        };
        l.addEventListener("abort", h, !0);
        const p = () => {
          l.removeEventListener("abort", h, !0);
        };
        return b.push(p), p;
      }, F = j((t) => {
        a(t), s(z(t));
      });
      o = j((t) => {
        i(t), s(t);
      }), u || (u = {});
      const { abortSignal: f, rejectOnAbort: A = !0 } = u;
      if (f)
        if (f.aborted) {
          const { reason: t } = f;
          if (A)
            return o(t);
          s(t);
        } else {
          const t = () => {
            s(f.reason);
          };
          f.addEventListener("abort", t), b.push(() => {
            f.removeEventListener("abort", t);
          });
        }
      A && E(i);
      const { timeout: m } = u;
      if (m) {
        const t = setTimeout(() => {
          s(new q(m));
        }, m);
        b.push(() => {
          clearTimeout(t);
        });
      }
      const L = () => l.aborted, T = () => S(v()), C = () => {
        const t = v();
        return S(t) ? t[1] : void 0;
      };
      try {
        const t = d && d(F, o, {
          abortReason: v,
          abortSignal: l,
          isAborted: L,
          isResolved: T,
          onAborted: E,
          onResolved: (h) => E(() => {
            T() && h(C());
          }),
          resolved: C,
          throwIfAborted() {
            if (L())
              throw v();
          }
        });
        t instanceof Promise && t.catch(o);
      } catch (t) {
        o(t);
      }
    });
    /**
     * Aborts the promise execution using the specified reason.
     *
     * Not that this method doesn't reject the promise but notifies the executor using its context.
     * To perform the same operation but also reject the promise, use the `reject()` method.
     * @param reason - abort reason.
     * @see reject
     */
    y(this, "abort");
    /**
     * Rejects the initially created promise.
     *
     * This method not only aborts the signal passed to the executor, but also rejects the
     * promise itself calling all chained listeners.
     *
     * The reason passed to the method is being passed as-is to the executor's context.
     */
    y(this, "reject");
    this.abort = s, this.reject = o;
  }
  /**
   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static fn(e, c) {
    return new w(async (o, s, a) => {
      try {
        o(await e(a));
      } catch (i) {
        s(i);
      }
    }, c);
  }
  static resolve(e) {
    return this.fn(() => e);
  }
  /**
   * @see Promise.reject
   */
  static reject(e) {
    return new w((c, o) => {
      o(e);
    });
  }
  /**
   * Aborts the promise with the cancel error.
   */
  cancel() {
    this.abort(new k());
  }
  /**
   * @see Promise.catch
   */
  catch(e) {
    return this.then(void 0, e);
  }
  /**
   * @see Promise.finally
   */
  finally(e) {
    return x(super.finally(e), this);
  }
  /**
   * @see Promise.then
   */
  then(e, c) {
    return x(super.then(e, c), this);
  }
}
function I(n, r) {
  return n.resolve = r.resolve, n;
}
class R extends w {
  constructor(e, c) {
    let o, s;
    typeof e == "function" ? (o = e, s = c) : s = e;
    let a;
    super((i, d, u) => {
      a = i, o && o(i, d, u);
    }, s);
    /**
     * Resolves the promise.
     */
    y(this, "resolve");
    this.resolve = a;
  }
  /**
   * Creates a new ManualPromise instance using an executor, resolving the promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static fn(e, c) {
    return new R((o, s, a) => {
      try {
        Promise.resolve(e(a)).then(o, s);
      } catch (i) {
        s(i);
      }
    }, c);
  }
  static resolve(e) {
    return this.fn(() => e);
  }
  /**
   * @see Promise.reject
   */
  static reject(e) {
    return new R((c, o) => {
      o(e);
    });
  }
  /**
   * @see Promise.catch
   */
  catch(e) {
    return this.then(void 0, e);
  }
  /**
   * @see Promise.finally
   */
  finally(e) {
    return I(super.finally(e), this);
  }
  /**
   * @see Promise.then
   */
  then(e, c) {
    return I(super.then(e, c), this);
  }
}
export {
  w as AbortablePromise,
  k as CancelledError,
  R as ManualPromise,
  q as TimeoutError,
  H as isCancelledError,
  S as isPromiseResolveResult,
  J as isTimeoutError
};
//# sourceMappingURL=index.js.map
