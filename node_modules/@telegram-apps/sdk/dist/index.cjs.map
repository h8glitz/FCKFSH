{"version":3,"file":"index.cjs","sources":["../../bridge/dist/index.js","../../toolkit/dist/index.js","../../navigation/dist/index.js","../../signals/dist/index.js","../src/signals-registry.ts","../src/debug.ts","../src/globals.ts","../src/scopes/createIsSupported.ts","../../../node_modules/.pnpm/error-kid@0.0.4/node_modules/error-kid/dist/index.js","../src/errors.ts","../src/utils/isSSR.ts","../src/scopes/wrappers/wrapSafe.ts","../src/scopes/wrappers/createWrapSafe.ts","../src/scopes/wrappers/createWrapComplete.ts","../src/scopes/wrappers/createWrapSupported.ts","../src/scopes/components/back-button/back-button.ts","../../../node_modules/.pnpm/better-promises@0.4.0/node_modules/better-promises/dist/index.js","../src/scopes/defineNonConcurrentFn.ts","../src/scopes/defineMountFn.ts","../src/scopes/wrappers/createWrapBasic.ts","../src/scopes/components/biometry/signals.ts","../src/scopes/components/biometry/requestBiometry.ts","../src/utils/ignoreCanceled.ts","../src/scopes/signalCancel.ts","../src/scopes/components/biometry/methods.ts","../src/scopes/wrappers/createWrapMounted.ts","../src/scopes/components/closing-behavior/closing-behavior.ts","../../../node_modules/.pnpm/valibot@1.0.0-beta.14_typescript@5.6.3/node_modules/valibot/dist/index.js","../src/scopes/components/cloud-storage/cloud-storage.ts","../src/scopes/components/haptic-feedback/haptic-feedback.ts","../src/scopes/components/init-data/init-data.ts","../src/scopes/components/invoice/invoice.ts","../src/utils/removeUndefined.ts","../../transformers/dist/index.js","../src/utils/isColorDark.ts","../src/scopes/components/theme-params/signals.ts","../src/scopes/components/main-button/signals.ts","../src/scopes/components/main-button/methods.ts","../src/utils/css-vars.ts","../src/scopes/components/theme-params/methods.ts","../src/scopes/components/mini-app/signals.ts","../src/scopes/components/mini-app/methods.ts","../src/scopes/components/popup/prepareParams.ts","../src/scopes/components/popup/popup.ts","../src/scopes/components/qr-scanner/qr-scanner.ts","../src/scopes/components/secondary-button/signals.ts","../src/scopes/components/secondary-button/methods.ts","../src/scopes/components/settings-button/settings-button.ts","../src/scopes/components/swipe-behavior/swipe-behavior.ts","../src/scopes/components/viewport/const.ts","../src/scopes/components/viewport/wrappers.ts","../src/scopes/components/viewport/signals.ts","../src/scopes/components/viewport/static.ts","../src/scopes/components/viewport/mounting.ts","../src/scopes/components/viewport/css-vars.ts","../src/scopes/components/viewport/expand.ts","../src/scopes/components/viewport/fullscreen.ts","../src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts","../src/scopes/utilities/emoji-status/setEmojiStatus.ts","../src/scopes/utilities/home-screen/add-to-home-screen-failed.ts","../src/scopes/utilities/home-screen/added-to-home-screen.ts","../src/scopes/utilities/home-screen/addToHomeScreen.ts","../src/scopes/utilities/home-screen/checkHomeScreenStatus.ts","../src/scopes/utilities/links/openLink.ts","../src/scopes/utilities/links/openTelegramLink.ts","../src/scopes/utilities/links/shareURL.ts","../src/utils/sleep.ts","../src/scopes/utilities/privacy/requestPhoneAccess.ts","../src/scopes/utilities/privacy/requestContact.ts","../src/scopes/utilities/privacy/requestWriteAccess.ts","../src/scopes/utilities/uncategorized/getCurrentTime.ts","../src/scopes/utilities/uncategorized/readTextFromClipboard.ts","../src/scopes/utilities/uncategorized/sendData.ts","../src/scopes/utilities/uncategorized/shareStory.ts","../src/scopes/utilities/uncategorized/switchInlineQuery.ts","../src/utils/safeCall.ts","../src/init.ts"],"sourcesContent":["var E;\n// @__NO_SIDE_EFFECTS__\nfunction Ee(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? (E == null ? void 0 : E.lang),\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? (E == null ? void 0 : E.abortEarly),\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? (E == null ? void 0 : E.abortPipeEarly)\n  };\n}\nvar N;\n// @__NO_SIDE_EFFECTS__\nfunction nt(t) {\n  return N == null ? void 0 : N.get(t);\n}\nvar C;\n// @__NO_SIDE_EFFECTS__\nfunction rt(t) {\n  return C == null ? void 0 : C.get(t);\n}\nvar U;\n// @__NO_SIDE_EFFECTS__\nfunction st(t, e) {\n  var n;\n  return (n = U == null ? void 0 : U.get(t)) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction it(t) {\n  var n, r;\n  const e = typeof t;\n  return e === \"string\" ? `\"${t}\"` : e === \"number\" || e === \"bigint\" || e === \"boolean\" ? `${t}` : e === \"object\" || e === \"function\" ? (t && ((r = (n = Object.getPrototypeOf(t)) == null ? void 0 : n.constructor) == null ? void 0 : r.name)) ?? \"null\" : e;\n}\nfunction A(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ it(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ st(t.reference, o.lang) ?? (c ? /* @__PURE__ */ rt(o.lang) : null) ?? r.message ?? /* @__PURE__ */ nt(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ Ee());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction at(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\nvar ot = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction Z(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction ke() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: ke,\n    expects: \"any\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: z,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction X(t) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: X,\n    expects: \"Function\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"function\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: v,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      var a;\n      const s = n.value;\n      if (s && typeof s == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in s || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ Z(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (a = n.issues) == null || a.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (A(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ at(s, i) && !(i in this.entries) && (n.value[i] = s[i]);\n      } else\n        A(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: T,\n    expects: `(${t.expects} | null | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return (n.value === null || n.value === void 0) && (this.default !== void 0 && (n.value = /* @__PURE__ */ Z(this, n, r)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction G(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: G,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction B(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: B,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ Z(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: k,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction xe() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: xe,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction F(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ Ee(n));\n  if (r.issues)\n    throw new ot(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $e(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction Pe(t) {\n  return /* @__PURE__ */ D(\n    /* @__PURE__ */ v({ TelegramWebviewProxy: /* @__PURE__ */ v({ postEvent: /* @__PURE__ */ X() }) }),\n    t\n  );\n}\nfunction Se() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nvar ut = Object.defineProperty, ct = (t, e, n) => e in t ? ut(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, ce = (t, e, n) => ct(t, typeof e != \"symbol\" ? e + \"\" : e, n);\nfunction pt(t) {\n  return (e) => e instanceof t;\n}\nfunction je(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, pt(n)];\n}\nconst [lt, cn] = je(\"CancelledError\", \"Promise was canceled\"), [ft, pn] = je(\n  \"TimeoutError\",\n  (t, e) => [`Timeout reached: ${t}ms`, { cause: e }]\n), Ae = Symbol(\"Resolved\");\nfunction pe(t) {\n  return Array.isArray(t) && t[0] === Ae;\n}\nfunction dt(t) {\n  return [Ae, t];\n}\nfunction le(t, e) {\n  return t.reject = e.reject, t.abort = e.abort, t;\n}\nlet qe = class K extends Promise {\n  constructor(e, n) {\n    let r, s;\n    super((a, i) => {\n      let u, o;\n      typeof e == \"function\" ? (u = e, o = n) : o = e;\n      const c = [], p = (f) => (...j) => {\n        const I = f(...j);\n        return c.forEach((tt) => tt()), I;\n      }, l = new AbortController(), { signal: y } = l;\n      s = (f) => {\n        !y.aborted && l.abort(f);\n      };\n      const b = () => y.reason, P = (f) => {\n        const j = () => {\n          f(b());\n        };\n        y.addEventListener(\"abort\", j, !0);\n        const I = () => {\n          y.removeEventListener(\"abort\", j, !0);\n        };\n        return c.push(I), I;\n      }, et = p((f) => {\n        a(f), s(dt(f));\n      });\n      r = p((f) => {\n        i(f), s(f);\n      }), o || (o = {});\n      const { abortSignal: S, rejectOnAbort: ie = !0 } = o;\n      if (S)\n        if (S.aborted) {\n          const { reason: f } = S;\n          if (ie)\n            return r(f);\n          s(f);\n        } else {\n          const f = () => {\n            s(S.reason);\n          };\n          S.addEventListener(\"abort\", f), c.push(() => {\n            S.removeEventListener(\"abort\", f);\n          });\n        }\n      ie && P(i);\n      const { timeout: R } = o;\n      if (R) {\n        const f = setTimeout(() => {\n          s(new ft(R));\n        }, R);\n        c.push(() => {\n          clearTimeout(f);\n        });\n      }\n      const ae = () => y.aborted, oe = () => pe(b()), ue = () => {\n        const f = b();\n        return pe(f) ? f[1] : void 0;\n      };\n      try {\n        const f = u && u(et, r, {\n          abortReason: b,\n          abortSignal: y,\n          isAborted: ae,\n          isResolved: oe,\n          onAborted: P,\n          onResolved: (j) => P(() => {\n            oe() && j(ue());\n          }),\n          resolved: ue,\n          throwIfAborted() {\n            if (ae())\n              throw b();\n          }\n        });\n        f instanceof Promise && f.catch(r);\n      } catch (f) {\n        r(f);\n      }\n    }), ce(this, \"abort\"), ce(this, \"reject\"), this.abort = s, this.reject = r;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, n) {\n    return new K(async (r, s, a) => {\n      try {\n        r(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, n);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new K((n, r) => {\n      r(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new lt());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return le(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, n) {\n    return le(super.then(e, n), this);\n  }\n};\nfunction _t(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction yt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[_t(n)] = r, e), {});\n}\nfunction Y(t) {\n  const e = yt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(Y) : Y(r));\n  }\n  return e;\n}\nfunction Me(t) {\n  return `tapps/${t}`;\n}\nfunction Te(t, e) {\n  sessionStorage.setItem(Me(t), JSON.stringify(e));\n}\nfunction bt(t) {\n  const e = sessionStorage.getItem(Me(t));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction ht(...t) {\n  const e = t.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((n) => {\n        n();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction mt(t, e) {\n  e || (e = {});\n  const {\n    textColor: n,\n    bgColor: r,\n    shouldLog: s\n  } = e, a = s === void 0 ? !0 : s, i = typeof a == \"boolean\" ? () => a : a;\n  function u(o, c, ...p) {\n    if (c || i()) {\n      const l = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[o](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${t}`,\n        `${l};background-color: lightblue;color:black`,\n        \"\",\n        `${l};${n ? `color:${n};` : \"\"}${r ? `background-color:${r}` : \"\"}`,\n        ...p\n      );\n    }\n  }\n  return [u.bind(void 0, \"log\"), u.bind(void 0, \"error\")];\n}\n// @__NO_SIDE_EFFECTS__\nfunction Le(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? void 0,\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? void 0,\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? void 0\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction gt(t, e) {\n  var n;\n  return (n = void 0) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction vt(t) {\n  var e, n;\n  const r = typeof t;\n  return r === \"string\" ? `\"${t}\"` : r === \"number\" || r === \"bigint\" || r === \"boolean\" ? `${t}` : r === \"object\" || r === \"function\" ? (t && ((n = (e = Object.getPrototypeOf(t)) == null ? void 0 : e.constructor) == null ? void 0 : n.name)) ?? \"null\" : r;\n}\nfunction m(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ vt(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ gt(t.reference, o.lang) ?? (c ? (o.lang, void 0) : null) ?? r.message ?? (o.lang, void 0);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction g(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ Le());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ie(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction wt(t, e) {\n  const n = [...new Set(t)];\n  return n.length > 1 ? `(${n.join(` ${e} `)})` : n[0] ?? \"never\";\n}\nvar Et = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction We(t, e) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: We,\n    async: !1,\n    expects: null,\n    requirement: t,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && m(this, \"input\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction De(t) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: De,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: t,\n    \"~run\"(e, n) {\n      return e.typed && !this.requirement(e.value) && m(this, \"integer\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(t) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: x,\n    async: !1,\n    operation: t,\n    \"~run\"(e) {\n      return e.value = this.operation(e.value), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Re(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction kt(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction L(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: L,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ne(t) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: Ne,\n    expects: \"Date\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return e.value instanceof Date ? isNaN(e.value) ? m(this, \"type\", e, n, {\n        received: '\"Invalid Date\"'\n      }) : e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ce(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: Ce,\n    expects: t.name,\n    async: !1,\n    class: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof this.class ? n.typed = !0 : m(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(t) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: V,\n    expects: \"unknown\",\n    async: !1,\n    getter: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return this.getter(e.value)[\"~run\"](e, n);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: q,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      var s;\n      const a = n.value;\n      if (a && typeof a == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in a || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in a ? (\n              // @ts-expect-error\n              a[i]\n            ) : /* @__PURE__ */ Re(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: a,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (s = n.issues) == null || s.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (m(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: a,\n                key: i,\n                // @ts-expect-error\n                value: a[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in a)\n            /* @__PURE__ */ Ie(a, i) && !(i in this.entries) && (n.value[i] = a[i]);\n      } else\n        m(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ee(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: ee,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: _,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ Re(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ue(t, e, n) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: Ue,\n    expects: \"Object\",\n    async: !1,\n    key: t,\n    value: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(r, s) {\n      var a, i;\n      const u = r.value;\n      if (u && typeof u == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ Ie(u, o)) {\n            const c = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of p.issues)\n                b.path = [y], (a = r.issues) == null || a.push(b);\n              if (r.issues || (r.issues = p.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            const l = this.value[\"~run\"](\n              { value: c },\n              s\n            );\n            if (l.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of l.issues)\n                b.path ? b.path.unshift(y) : b.path = [y], (i = r.issues) == null || i.push(b);\n              if (r.issues || (r.issues = l.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !l.typed) && (r.typed = !1), p.typed && (r.value[p.value] = l.value);\n          }\n      } else\n        m(this, \"type\", r, s);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: d,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction fe(t) {\n  let e;\n  if (t)\n    for (const n of t)\n      e ? e.push(...n.issues) : e = n.issues;\n  return e;\n}\n// @__NO_SIDE_EFFECTS__\nfunction Oe(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: Oe,\n    expects: /* @__PURE__ */ wt(\n      t.map((n) => n.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      let s, a, i;\n      for (const u of this.options) {\n        const o = u[\"~run\"]({ value: n.value }, r);\n        if (o.typed)\n          if (o.issues)\n            a ? a.push(o) : a = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (a) {\n        if (a.length === 1)\n          return a[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ fe(a)\n        }), n.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ fe(i)\n        });\n      }\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Je() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: Je,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction ze(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ Le(n));\n  if (r.issues)\n    throw new Et(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction xt(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction $t(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[xt(n)] = r, e), {});\n}\nfunction H(t) {\n  const e = $t(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(H) : H(r));\n  }\n  return e;\n}\nfunction te(t) {\n  return /* @__PURE__ */ x((e) => t ? H(e) : e);\n}\nfunction Ge(t) {\n  return (e) => /* @__PURE__ */ $(\n    t,\n    te(e)\n  );\n}\nfunction Pt(t) {\n  return (e, n) => ze(\n    /* @__PURE__ */ $(t, te(n)),\n    e\n  );\n}\nfunction ne() {\n  return /* @__PURE__ */ x(JSON.parse);\n}\nfunction re(t) {\n  const e = Ge(t);\n  return (n) => /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    ne(),\n    e(n)\n  );\n}\nfunction St(t) {\n  return /* @__PURE__ */ x((e) => {\n    const n = {};\n    return new URLSearchParams(e).forEach((r, s) => {\n      const a = n[s];\n      Array.isArray(a) ? a.push(r) : a === void 0 ? n[s] = r : n[s] = [a, r];\n    }), ze(t, n);\n  });\n}\nfunction Be(t) {\n  return (e) => /* @__PURE__ */ $(\n    /* @__PURE__ */ Oe([/* @__PURE__ */ d(), /* @__PURE__ */ Ce(URLSearchParams)]),\n    St(t),\n    te(e)\n  );\n}\nconst de = /* @__PURE__ */ _(/* @__PURE__ */ V(() => Tt())), jt = /* @__PURE__ */ q({\n  id: /* @__PURE__ */ ee(),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  type: /* @__PURE__ */ d(),\n  title: /* @__PURE__ */ d(),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), At = /* @__PURE__ */ q({\n  added_to_attachment_menu: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  allows_write_to_pm: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  first_name: /* @__PURE__ */ d(),\n  id: /* @__PURE__ */ ee(),\n  is_bot: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  is_premium: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  last_name: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  language_code: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), qt = /* @__PURE__ */ q({\n  auth_date: /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ x((t) => new Date(Number(t) * 1e3)),\n    /* @__PURE__ */ Ne()\n  ),\n  can_send_after: /* @__PURE__ */ _(/* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x(Number), /* @__PURE__ */ De())),\n  chat: /* @__PURE__ */ _(/* @__PURE__ */ V(() => Mt())),\n  chat_type: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  chat_instance: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  hash: /* @__PURE__ */ d(),\n  query_id: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  receiver: de,\n  start_param: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  signature: /* @__PURE__ */ d(),\n  user: de\n}), Mt = re(jt), Tt = re(At), Lt = Be(qt);\nfunction It(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nconst Wt = Ge(\n  /* @__PURE__ */ Ue(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ We(It), /* @__PURE__ */ x((t) => t))\n  )\n), O = /* @__PURE__ */ _(\n  /* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x((t) => t === \"1\"))\n), _e = re(Wt()), Dt = /* @__PURE__ */ q({\n  tgWebAppBotInline: O,\n  tgWebAppData: /* @__PURE__ */ _(Lt()),\n  tgWebAppDefaultColors: /* @__PURE__ */ _(_e()),\n  tgWebAppFullscreen: O,\n  tgWebAppPlatform: /* @__PURE__ */ d(),\n  tgWebAppShowSettings: O,\n  tgWebAppStartParam: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  tgWebAppThemeParams: _e(),\n  tgWebAppVersion: /* @__PURE__ */ d()\n}), Fe = Be(Dt), Rt = Pt(Fe()), Ke = /* @__PURE__ */ q({\n  eventType: /* @__PURE__ */ d(),\n  eventData: /* @__PURE__ */ _(/* @__PURE__ */ Je())\n});\nfunction Ye(t, e) {\n  return e || (e = (n, r) => JSON.stringify(r)), new URLSearchParams(\n    Object.entries(t).reduce((n, [r, s]) => (Array.isArray(s) ? n.push(...s.map((a) => [r, String(a)])) : s != null && n.push([\n      r,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : e(r, s)\n    ]), n), [])\n  ).toString();\n}\nfunction Nt(t) {\n  return Ye(t);\n}\nfunction Ct(t) {\n  return Ye(t, (e, n) => e === \"tgWebAppData\" ? Nt(n) : JSON.stringify(n));\n}\nfunction He(t) {\n  try {\n    return /* @__PURE__ */ kt(Fe(), t);\n  } catch {\n    return !1;\n  }\n}\nfunction Ut(t) {\n  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, n) {\n    var r = t.get(e);\n    r ? r.push(n) : t.set(e, [n]);\n  }, off: function(e, n) {\n    var r = t.get(e);\n    r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : t.set(e, []));\n  }, emit: function(e, n) {\n    var r = t.get(e);\n    r && r.slice().map(function(s) {\n      s(n);\n    }), (r = t.get(\"*\")) && r.slice().map(function(s) {\n      s(e, n);\n    });\n  } };\n}\nfunction Ot(t, e) {\n  const n = Ut(), r = /* @__PURE__ */ new Map(), s = (a, i, u) => {\n    u || (u = !1);\n    const o = r.get(a) || /* @__PURE__ */ new Map();\n    r.set(a, o);\n    const c = o.get(i) || [];\n    o.set(i, c);\n    const p = c.findIndex((l) => l[1] === u);\n    p >= 0 && (n.off(a, c[p][0]), c.splice(p, 1), !c.length && o.delete(i), o.size || (r.delete(a), !r.size && e()));\n  };\n  return [\n    function(i, u, o) {\n      !r.size && t();\n      function c() {\n        s(i, u, o);\n      }\n      function p(...b) {\n        o && c(), i === \"*\" ? u(b) : u(...b);\n      }\n      n.on(i, p);\n      const l = r.get(i) || /* @__PURE__ */ new Map();\n      r.set(i, l);\n      const y = l.get(u) || [];\n      return l.set(u, y), y.push([p, o || !1]), c;\n    },\n    s,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    n.emit,\n    function() {\n      const i = n.all.size;\n      n.all.clear(), r.clear(), i && e();\n    }\n  ];\n}\nfunction ye(t, e) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: t, eventData: e }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nlet W = !1;\nconst [se, Jt] = /* @__PURE__ */ mt(\"Bridge\", {\n  bgColor: \"#9147ff\",\n  textColor: \"white\",\n  shouldLog() {\n    return W;\n  }\n}), be = (t) => {\n  se(!1, \"Event received:\", t);\n};\nfunction zt(t) {\n  t !== W && (W = t, W ? Qe(\"*\", be) : Bt(\"*\", be));\n}\nconst Gt = {\n  clipboard_text_received: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    data: /* @__PURE__ */ T(/* @__PURE__ */ k())\n  }),\n  custom_method_invoked: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    result: /* @__PURE__ */ B(/* @__PURE__ */ xe()),\n    error: /* @__PURE__ */ B(/* @__PURE__ */ k())\n  }),\n  popup_closed: /* @__PURE__ */ T(\n    /* @__PURE__ */ v({ button_id: /* @__PURE__ */ T(/* @__PURE__ */ k(), () => {\n    }) }),\n    {}\n  ),\n  viewport_changed: /* @__PURE__ */ v({\n    height: /* @__PURE__ */ G(),\n    width: /* @__PURE__ */ T(/* @__PURE__ */ G(), () => window.innerWidth),\n    is_state_stable: /* @__PURE__ */ z(),\n    is_expanded: /* @__PURE__ */ z()\n  })\n};\nfunction he(t) {\n  if (t.source !== window.parent)\n    return;\n  let e;\n  try {\n    e = F(/* @__PURE__ */ $e(/* @__PURE__ */ k(), ne(), Ke), t.data);\n  } catch {\n    return;\n  }\n  const { eventType: n, eventData: r } = e, s = Gt[n];\n  try {\n    const a = s ? F(s, r) : r;\n    Ft(n, a);\n  } catch (a) {\n    Jt(\n      !0,\n      [\n        `An error occurred processing the \"${n}\" event from the Telegram application.`,\n        \"Please, file an issue here:\",\n        \"https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose\"\n      ].join(`\n`),\n      e,\n      a\n    );\n  }\n}\nconst [\n  Qe,\n  Bt,\n  Ft,\n  Kt\n] = Ot(\n  () => {\n    const t = window, e = { receiveEvent: ye };\n    t.TelegramGameProxy_receiveEvent = ye, t.TelegramGameProxy = e, t.Telegram = { WebView: e }, window.addEventListener(\"message\", he);\n  },\n  () => {\n    [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((t) => {\n      delete window[t];\n    }), window.removeEventListener(\"message\", he);\n  }\n);\nfunction Yt(t) {\n  return (e) => e instanceof t;\n}\nfunction M(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, Yt(n)];\n}\nconst [\n  Ht,\n  ln\n] = M(\n  \"MethodUnsupportedError\",\n  (t, e) => [\n    `Method \"${t}\" is unsupported in Mini Apps version ${e}`\n  ]\n), [\n  Qt,\n  fn\n] = M(\n  \"MethodParameterUnsupportedError\",\n  (t, e, n) => [\n    `Parameter \"${e}\" of \"${t}\" method is unsupported in Mini Apps version ${n}`\n  ]\n), Zt = [\n  \"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\",\n  \"ðŸ“– Refer to docs for more information:\",\n  \"https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment\"\n].join(`\n`), [\n  Xt,\n  dn\n] = M(\"LaunchParamsRetrieveError\", Zt), [\n  Vt,\n  _n\n] = M(\"InvalidLaunchParamsError\", (t) => [\n  `Invalid value for launch params: ${t}`\n]), [en, yn] = M(\"UnknownEnvError\"), [\n  tn,\n  bn\n] = M(\n  \"InvokeCustomMethodError\",\n  (t) => [`Server returned error: ${t}`]\n);\nfunction nn(t, e) {\n  e();\n}\n// @__NO_SIDE_EFFECTS__\nfunction rn(t, e) {\n  e || (e = {});\n  const n = e.equals || Object.is;\n  let r = [], s = t;\n  const a = (c) => {\n    if (!n(s, c)) {\n      const p = s;\n      s = c, nn(o, () => {\n        [...r].forEach(([l, y]) => {\n          l(c, p), y && u(l, !0);\n        });\n      });\n    }\n  };\n  function i(c) {\n    const p = typeof c != \"object\" ? { once: c } : c;\n    return {\n      once: p.once || !1,\n      signal: p.signal || !1\n    };\n  }\n  const u = (c, p) => {\n    const l = i(p), y = r.findIndex(([b, P]) => b === c && P.once === l.once && P.signal === l.signal);\n    y >= 0 && r.splice(y, 1);\n  }, o = Object.assign(\n    function() {\n      return sn(o), s;\n    },\n    {\n      destroy() {\n        r = [];\n      },\n      set: a,\n      reset() {\n        a(t);\n      },\n      sub(c, p) {\n        return r.push([c, i(p)]), () => u(c, p);\n      },\n      unsub: u,\n      unsubAll() {\n        r = r.filter((c) => c[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst J = [];\nfunction sn(t) {\n  J.length && J[J.length - 1].add(t);\n}\nconst Q = /* @__PURE__ */ rn(\"https://web.telegram.org\");\nfunction Ze(t, e) {\n  se(!1, \"Posting event:\", e ? { eventType: t, eventData: e } : { eventType: t });\n  const n = window, r = JSON.stringify({ eventType: t, eventData: e });\n  if (Se())\n    return n.parent.postMessage(r, Q());\n  if (Pe(n)) {\n    n.TelegramWebviewProxy.postEvent(t, JSON.stringify(e));\n    return;\n  }\n  if (/* @__PURE__ */ D(/* @__PURE__ */ v({ external: /* @__PURE__ */ v({ notify: /* @__PURE__ */ X() }) }), n)) {\n    n.external.notify(r);\n    return;\n  }\n  throw new en();\n}\nfunction Xe(t, e, n) {\n  n || (n = {});\n  const { capture: r } = n, [s, a] = ht();\n  return new qe((i) => {\n    (Array.isArray(e) ? e : [e]).forEach((u) => {\n      s(\n        Qe(u, (o) => {\n          (!r || (Array.isArray(e) ? r({\n            event: u,\n            payload: o\n          }) : r(o))) && i(o);\n        })\n      );\n    }), (n.postEvent || Ze)(t, n.params);\n  }, n).finally(a);\n}\nconst me = \"launchParams\";\nfunction ge(t) {\n  return t.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\");\n}\nfunction Ve() {\n  for (const t of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    () => ge(window.location.href),\n    // Then, try using the lower level API - window.performance.\n    () => {\n      const e = performance.getEntriesByType(\"navigation\")[0];\n      return e && ge(e.name);\n    },\n    () => bt(me)\n  ]) {\n    const e = t();\n    if (e && He(e))\n      return Te(me, e), e;\n  }\n  throw new Xt();\n}\nfunction an(t) {\n  const e = Rt(Ve());\n  return t ? Y(e) : e;\n}\nfunction hn(t, e) {\n  if (!t)\n    try {\n      return an(), !0;\n    } catch {\n      return !1;\n    }\n  return qe.fn(async (n) => {\n    if (Pe(window))\n      return !0;\n    try {\n      return await Xe(\"web_app_request_theme\", \"theme_changed\", n), !0;\n    } catch {\n      return !1;\n    }\n  }, e || { timeout: 100 });\n}\nfunction mn({ launchParams: t, onEvent: e } = {}) {\n  if (t) {\n    const s = typeof t == \"string\" || t instanceof URLSearchParams ? t.toString() : (\n      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n      // value. We are doing it because we are working with tgWebAppData presented as a\n      // string, not an object as serializeLaunchParamsQuery requires.\n      Ct({ ...t, tgWebAppData: void 0 }) + (t.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(t.tgWebAppData.toString())}` : \"\")\n    );\n    if (!He(s))\n      throw new Vt(s);\n    Te(\"launchParams\", s);\n  }\n  if (Se()) {\n    const s = /* @__PURE__ */ $e(\n      /* @__PURE__ */ k(),\n      ne(),\n      Ke\n    ), a = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (...i) => {\n      const [u] = i, o = () => {\n        a(...i);\n      };\n      if (/* @__PURE__ */ D(s, u) && e) {\n        const c = F(s, u);\n        e([c.eventType, c.eventData], o);\n      } else\n        o();\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy || {}, { postEvent: r } = n;\n  window.TelegramWebviewProxy = {\n    ...n,\n    postEvent(s, a) {\n      const i = () => {\n        r && r(s, a);\n      };\n      e ? e([s, a ? JSON.parse(a) : void 0], i) : i();\n    }\n  }, se(!1, \"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction gn() {\n  return new URLSearchParams(Ve()).get(\"tgWebAppData\") || void 0;\n}\nfunction on(t) {\n  return ({ req_id: e }) => e === t;\n}\nfunction ve(t) {\n  return t.split(\".\").map(Number);\n}\nfunction un(t, e) {\n  const n = ve(t), r = ve(e), s = Math.max(n.length, r.length);\n  for (let a = 0; a < s; a += 1) {\n    const i = n[a] || 0, u = r[a] || 0;\n    if (i !== u)\n      return i > u ? 1 : -1;\n  }\n  return 0;\n}\nfunction h(t, e) {\n  return un(t, e) <= 0;\n}\nfunction we(t, e, n) {\n  if (typeof n == \"string\") {\n    if (t === \"web_app_open_link\") {\n      if (e === \"try_instant_view\")\n        return h(\"6.4\", n);\n      if (e === \"try_browser\")\n        return h(\"7.6\", n);\n    }\n    if (t === \"web_app_set_header_color\" && e === \"color\")\n      return h(\"6.9\", n);\n    if (t === \"web_app_close\" && e === \"return_back\")\n      return h(\"7.6\", n);\n    if (t === \"web_app_setup_main_button\" && e === \"has_shine_effect\")\n      return h(\"7.10\", n);\n  }\n  switch (t) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return h(\"6.1\", e);\n    case \"web_app_open_popup\":\n      return h(\"6.2\", e);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return h(\"6.4\", e);\n    case \"web_app_switch_inline_query\":\n      return h(\"6.7\", e);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return h(\"6.9\", e);\n    case \"web_app_setup_settings_button\":\n      return h(\"6.10\", e);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return h(\"7.2\", e);\n    case \"web_app_setup_swipe_behavior\":\n      return h(\"7.7\", e);\n    case \"web_app_share_to_story\":\n      return h(\"7.8\", e);\n    case \"web_app_setup_secondary_button\":\n    case \"web_app_set_bottom_bar_color\":\n      return h(\"7.10\", e);\n    case \"web_app_request_safe_area\":\n    case \"web_app_request_content_safe_area\":\n    case \"web_app_request_fullscreen\":\n    case \"web_app_exit_fullscreen\":\n    case \"web_app_set_emoji_status\":\n    case \"web_app_add_to_home_screen\":\n    case \"web_app_check_home_screen\":\n    case \"web_app_request_emoji_status_access\":\n    case \"web_app_check_location\":\n    case \"web_app_open_location_settings\":\n    case \"web_app_request_file_download\":\n    case \"web_app_request_location\":\n    case \"web_app_send_prepared_message\":\n    case \"web_app_start_accelerometer\":\n    case \"web_app_start_device_orientation\":\n    case \"web_app_start_gyroscope\":\n    case \"web_app_stop_accelerometer\":\n    case \"web_app_stop_device_orientation\":\n    case \"web_app_stop_gyroscope\":\n    case \"web_app_toggle_orientation_lock\":\n      return h(\"8.0\", e);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(t);\n  }\n}\nfunction vn(t, e) {\n  e || (e = \"strict\");\n  const n = typeof e == \"function\" ? e : (r) => {\n    const { method: s, version: a } = r, i = \"param\" in r ? new Qt(s, r.param, a) : new Ht(s, a);\n    if (e === \"strict\")\n      throw i;\n    return console.warn(i.message);\n  };\n  return (r, s) => we(r, t) ? r === \"web_app_set_header_color\" && /* @__PURE__ */ D(/* @__PURE__ */ v({ color: /* @__PURE__ */ ke() }), s) && !we(r, \"color\", t) ? n({ version: t, method: r, param: \"color\" }) : Ze(r, s) : n({ version: t, method: r });\n}\nfunction wn(t, e, n, r) {\n  return Xe(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n    ...r || {},\n    params: { method: t, params: e, req_id: n },\n    capture: on(n)\n  }).then(({ result: s, error: a }) => {\n    if (a)\n      throw new tn(a);\n    return s;\n  });\n}\nfunction En() {\n  Kt(), zt(!1), Q.unsubAll(), Q.reset();\n}\nexport {\n  Vt as InvalidLaunchParamsError,\n  tn as InvokeCustomMethodError,\n  Xt as LaunchParamsRetrieveError,\n  Qt as MethodParameterUnsupportedError,\n  Ht as MethodUnsupportedError,\n  en as UnknownEnvError,\n  on as captureSameReq,\n  un as compareVersions,\n  vn as createPostEvent,\n  ye as emitEvent,\n  Pe as hasWebviewProxy,\n  wn as invokeCustomMethod,\n  Se as isIframe,\n  _n as isInvalidLaunchParamsError,\n  bn as isInvokeCustomMethodError,\n  dn as isLaunchParamsRetrieveError,\n  fn as isMethodMethodParameterUnsupportedError,\n  ln as isMethodUnsupportedError,\n  hn as isTMA,\n  yn as isUnknownEnvError,\n  mn as mockTelegramEnv,\n  Bt as off,\n  Kt as offAll,\n  Qe as on,\n  Ze as postEvent,\n  Xe as request,\n  En as resetPackageState,\n  an as retrieveLaunchParams,\n  gn as retrieveRawInitData,\n  Ve as retrieveRawLaunchParams,\n  zt as setDebug,\n  we as supports,\n  Q as targetOrigin\n};\n//# sourceMappingURL=index.js.map\n","function C(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction b(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction $(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[b(t)] = n, e), {});\n}\nfunction p(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction m(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[p(t)] = n, e), {});\n}\nfunction s(o) {\n  const e = m(o);\n  for (const t in e) {\n    const n = e[t];\n    n && typeof n == \"object\" && !(n instanceof Date) && (e[t] = Array.isArray(n) ? n.map(s) : s(n));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, t) => `-${t.toLowerCase()}`);\n}\nfunction u(o) {\n  return `tapps/${o}`;\n}\nfunction y(o, e) {\n  sessionStorage.setItem(u(o), JSON.stringify(e));\n}\nfunction S(o) {\n  const e = sessionStorage.getItem(u(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction h(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(o, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: a\n  } = e, r = a === void 0 ? !0 : a, l = typeof r == \"boolean\" ? () => r : r;\n  function c(g, d, ...f) {\n    if (d || l()) {\n      const i = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[g](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${o}`,\n        `${i};background-color: lightblue;color:black`,\n        \"\",\n        `${i};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n        ...f\n      );\n    }\n  }\n  return [c.bind(void 0, \"log\"), c.bind(void 0, \"error\")];\n}\nexport {\n  C as camelToKebab,\n  b as camelToSnake,\n  $ as camelToSnakeObjKeys,\n  h as createCbCollector,\n  T as createLogger,\n  s as deepSnakeToCamelObjKeys,\n  S as getStorageValue,\n  y as setStorageValue,\n  p as snakeToCamel,\n  m as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n","function i() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction c() {\n  const t = i();\n  return !!t && t.type === \"reload\";\n}\nfunction o(t, n) {\n  return t.startsWith(n) ? t : `${n}${t}`;\n}\nfunction R(t) {\n  return new URL(\n    typeof t == \"string\" ? t : [\n      t.pathname || \"\",\n      o(t.search || \"\", \"?\"),\n      o(t.hash || \"\", \"#\")\n    ].join(\"\"),\n    \"http://a\"\n  );\n}\nfunction a(t) {\n  const n = (typeof t == \"string\" ? t : t.pathname || \"\").startsWith(\"/\"), e = R(t), { pathname: s } = e;\n  return `${n ? s : s.slice(1)}${e.search}${e.hash}`;\n}\nconst r = \"ERR_NAVIGATION_HISTORY_EMPTY\", I = \"ERR_NAVIGATION_CURSOR_INVALID\";\nexport {\n  I as ERR_CURSOR_INVALID,\n  r as ERR_HISTORY_EMPTY,\n  R as createSafeURL,\n  o as ensurePrefix,\n  i as getFirstNavigationEntry,\n  c as isPageReload,\n  a as urlToPath\n};\n//# sourceMappingURL=index.js.map\n","let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n","import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}","import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nlet debug = false;\n\nexport const [logInfo, logError] = createLogger('SDK', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n});\n\n/**\n * Sets the package debug mode leading to outputting additional logs.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}","import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logInfo } from '@/debug.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   *\n   * Passing the \"strict\" value creates a function, which always checks if specified call supported\n   * by currently supported Mini Apps version. If the method is unsupported, an error will be\n   * thrown.\n   *\n   * Passing the \"non-strict\" value creates a postEvent function not throwing any errors, but\n   * warning about a missing method support.\n   *\n   * @default 'strict'\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_launchParams, launchParams] =\n  createSignalsTuple<PackageLaunchParams>({\n    tgWebAppPlatform: 'unknown',\n    tgWebAppVersion: '0.0',\n  });\n\nexport const version = createComputed(() => launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logInfo(false, 'The package was configured. Launch params:', _launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n","import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}","var f = Object.defineProperty;\nvar u = (t, r, n) => r in t ? f(t, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[r] = n;\nvar c = (t, r, n) => u(t, typeof r != \"symbol\" ? r + \"\" : r, n);\nfunction i(t) {\n  return (r) => r instanceof t;\n}\nfunction d(t, r) {\n  r || (r = []);\n  class n extends Error {\n    constructor(...e) {\n      const o = typeof r == \"function\" ? r(...e) : typeof r == \"string\" ? [r] : r || [];\n      super(...o), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, i(n)];\n}\nfunction m(t, r, n) {\n  class s extends d(t, n)[0] {\n    constructor(...a) {\n      super(...a);\n      c(this, \"data\");\n      this.data = r(...a);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: t }), [s, i(s)];\n}\nexport {\n  d as errorClass,\n  m as errorClassWithData,\n  i as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);","/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n","import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n","import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n","import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n","import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","var V = Object.defineProperty;\nvar Y = (n, r, e) => r in n ? V(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e;\nvar y = (n, r, e) => Y(n, typeof r != \"symbol\" ? r + \"\" : r, e);\nfunction $(n) {\n  return (r) => r instanceof n;\n}\nfunction B(n, r) {\n  r || (r = []);\n  class e extends Error {\n    constructor(...o) {\n      const s = typeof r == \"function\" ? r(...o) : typeof r == \"string\" ? [r] : r || [];\n      super(...s), this.name = n;\n    }\n  }\n  return Object.defineProperty(e, \"name\", { value: n }), [e, $(e)];\n}\nconst [k, H] = B(\"CancelledError\", \"Promise was canceled\"), [q, J] = B(\n  \"TimeoutError\",\n  (n, r) => [`Timeout reached: ${n}ms`, { cause: r }]\n), D = Symbol(\"Resolved\");\nfunction S(n) {\n  return Array.isArray(n) && n[0] === D;\n}\nfunction z(n) {\n  return [D, n];\n}\nfunction x(n, r) {\n  return n.reject = r.reject, n.abort = r.abort, n;\n}\nclass w extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let d, u;\n      typeof e == \"function\" ? (d = e, u = c) : u = e;\n      const b = [], j = (t) => (...h) => {\n        const p = t(...h);\n        return b.forEach((P) => P()), p;\n      }, g = new AbortController(), { signal: l } = g;\n      s = (t) => {\n        !l.aborted && g.abort(t);\n      };\n      const v = () => l.reason, E = (t) => {\n        const h = () => {\n          t(v());\n        };\n        l.addEventListener(\"abort\", h, !0);\n        const p = () => {\n          l.removeEventListener(\"abort\", h, !0);\n        };\n        return b.push(p), p;\n      }, F = j((t) => {\n        a(t), s(z(t));\n      });\n      o = j((t) => {\n        i(t), s(t);\n      }), u || (u = {});\n      const { abortSignal: f, rejectOnAbort: A = !0 } = u;\n      if (f)\n        if (f.aborted) {\n          const { reason: t } = f;\n          if (A)\n            return o(t);\n          s(t);\n        } else {\n          const t = () => {\n            s(f.reason);\n          };\n          f.addEventListener(\"abort\", t), b.push(() => {\n            f.removeEventListener(\"abort\", t);\n          });\n        }\n      A && E(i);\n      const { timeout: m } = u;\n      if (m) {\n        const t = setTimeout(() => {\n          s(new q(m));\n        }, m);\n        b.push(() => {\n          clearTimeout(t);\n        });\n      }\n      const L = () => l.aborted, T = () => S(v()), C = () => {\n        const t = v();\n        return S(t) ? t[1] : void 0;\n      };\n      try {\n        const t = d && d(F, o, {\n          abortReason: v,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: T,\n          onAborted: E,\n          onResolved: (h) => E(() => {\n            T() && h(C());\n          }),\n          resolved: C,\n          throwIfAborted() {\n            if (L())\n              throw v();\n          }\n        });\n        t instanceof Promise && t.catch(o);\n      } catch (t) {\n        o(t);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new w(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new w((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new k());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(n, r) {\n  return n.resolve = r.resolve, n;\n}\nclass R extends w {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, d, u) => {\n      a = i, o && o(i, d, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport {\n  w as AbortablePromise,\n  k as CancelledError,\n  R as ManualPromise,\n  q as TimeoutError,\n  H as isCancelledError,\n  S as isPromiseResolveResult,\n  J as isTimeoutError\n};\n//# sourceMappingURL=index.js.map\n","import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}","import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n","import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;","import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n","import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n","import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}","import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}","import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n","import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","import { AbortablePromise } from 'better-promises';\nimport { array, check, parse, pipe, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      return parse(\n        record(\n          pipe(string(), check(v => keys.includes(v))),\n          string(),\n        ),\n        data,\n      );\n    })\n    : AbortablePromise.resolve(typeof keyOrKeys === 'string' ? '' : {});\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n","import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');","import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}","var b;\n// @__NO_SIDE_EFFECTS__\nfunction G(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar E;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return E == null ? void 0 : E.get(e);\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = P == null ? void 0 : P.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {\n    kind: e.kind,\n    type: e.type,\n    input: u,\n    expected: i,\n    received: l,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n    requirement: e.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: t.lang,\n    abortEarly: t.abortEarly,\n    abortPipeEarly: t.abortPipeEarly\n  }, y = e.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({ value: n }, /* @__PURE__ */ G());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction N(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: W,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction L(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: v,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e, n, r) {\n  return typeof e.default == \"function\" ? (\n    // @ts-expect-error\n    e.default(n, r)\n  ) : (\n    // @ts-expect-error\n    e.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({ value: n }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: U,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: z,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: w,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") && // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ R(l), y = l[\"~run\"]({ value: o }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues)\n                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), t.abortEarly))\n            break;\n        }\n        if (!r.issues || !t.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ N(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else\n        f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: A,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ R(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: J,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ N(u, o)) {\n            const y = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of p.issues)\n                g.path = [S], (i = t.issues) == null || i.push(g);\n              if (t.issues || (t.issues = p.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            const m = this.value[\"~run\"](\n              { value: y },\n              s\n            );\n            if (m.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of m.issues)\n                g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n              if (t.issues || (t.issues = m.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n          }\n      } else\n        f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction C(e) {\n  let n;\n  if (e)\n    for (const r of e)\n      n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: V,\n    expects: /* @__PURE__ */ te(\n      e.map((r) => r.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({ value: r.value }, t);\n        if (o.typed)\n          if (o.issues)\n            u ? u.push(o) : u = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (u) {\n        if (u.length === 1)\n          return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ C(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ C(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({ value: n }, /* @__PURE__ */ G(r));\n  if (t.issues)\n    throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e)\n        if (t.kind !== \"metadata\") {\n          if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n            n.typed = !1;\n            break;\n          }\n          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n        }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction x(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(x) : x(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */ v((n) => e ? x(n) : n);\n}\nfunction M(e) {\n  return (n) => /* @__PURE__ */ d(\n    e,\n    I(n)\n  );\n}\nfunction T(e) {\n  return (n, r) => B(\n    /* @__PURE__ */ d(e, I(r)),\n    n\n  );\n}\nfunction oe() {\n  return /* @__PURE__ */ v(JSON.parse);\n}\nfunction $(e) {\n  const n = M(e);\n  return (r) => /* @__PURE__ */ d(\n    /* @__PURE__ */ a(),\n    oe(),\n    n(r)\n  );\n}\nfunction ce(e) {\n  return /* @__PURE__ */ v((n) => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return (n) => /* @__PURE__ */ d(\n    /* @__PURE__ */ V([/* @__PURE__ */ a(), /* @__PURE__ */ z(URLSearchParams)]),\n    ce(e),\n    I(n)\n  );\n}\nconst O = /* @__PURE__ */ c(/* @__PURE__ */ w(() => he())), le = /* @__PURE__ */ k({\n  id: /* @__PURE__ */ A(),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  type: /* @__PURE__ */ a(),\n  title: /* @__PURE__ */ a(),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), pe = /* @__PURE__ */ k({\n  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  first_name: /* @__PURE__ */ a(),\n  id: /* @__PURE__ */ A(),\n  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), fe = /* @__PURE__ */ k({\n  auth_date: /* @__PURE__ */ d(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ v((e) => new Date(Number(e) * 1e3)),\n    /* @__PURE__ */ U()\n  ),\n  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ d(/* @__PURE__ */ a(), /* @__PURE__ */ v(Number), /* @__PURE__ */ L())),\n  chat: /* @__PURE__ */ c(/* @__PURE__ */ w(() => ye())),\n  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  hash: /* @__PURE__ */ a(),\n  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  receiver: O,\n  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  signature: /* @__PURE__ */ a(),\n  user: O\n}), ye = $(le), he = $(pe), F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n))\n    return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1)\n      t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(\n  /* @__PURE__ */ J(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ d(/* @__PURE__ */ a(), /* @__PURE__ */ W(H), /* @__PURE__ */ v((e) => e))\n  )\n), j = /* @__PURE__ */ c(\n  /* @__PURE__ */ d(/* @__PURE__ */ a(), /* @__PURE__ */ v((e) => e === \"1\"))\n), Q = $(be()), ve = /* @__PURE__ */ k({\n  tgWebAppBotInline: j,\n  tgWebAppData: /* @__PURE__ */ c(F()),\n  tgWebAppDefaultColors: /* @__PURE__ */ c(Q()),\n  tgWebAppFullscreen: j,\n  tgWebAppPlatform: /* @__PURE__ */ a(),\n  tgWebAppShowSettings: j,\n  tgWebAppStartParam: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  tgWebAppThemeParams: Q(),\n  tgWebAppVersion: /* @__PURE__ */ a()\n}), X = K(ve), ke = T(F()), _e = T(X()), Se = /* @__PURE__ */ k({\n  eventType: /* @__PURE__ */ a(),\n  eventData: /* @__PURE__ */ c(/* @__PURE__ */ q())\n});\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(\n    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([\n      t,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)\n    ]), r), [])\n  ).toString();\n}\nfunction de(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? de(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport {\n  le as InitDataChatSchema,\n  fe as InitDataQuerySchema,\n  pe as InitDataUserSchema,\n  ve as LaunchParamsSchema,\n  Se as MiniAppsMessageSchema,\n  I as conditionalSnakeKeys,\n  M as createCamelCaseGen,\n  T as createCamelCaseSchemaParserGen,\n  $ as createJsonCamelCaseGen,\n  K as createQueryCamelCaseGen,\n  ye as initDataChatJson,\n  F as initDataQuery,\n  he as initDataUserJson,\n  De as isLaunchParamsQuery,\n  H as isRGB,\n  me as isRGBShort,\n  oe as jsonParse,\n  X as launchParamsQuery,\n  ke as parseInitDataQuery,\n  _e as parseLaunchParamsQuery,\n  de as serializeInitDataQuery,\n  Ee as serializeLaunchParamsQuery,\n  Y as serializeToQuery,\n  be as themeParams,\n  ge as toRGB,\n  ce as transformQueryUsing\n};\n//# sourceMappingURL=index.js.map\n","import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n","import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accentTextColor');\n\nexport const backgroundColor = fromState('bgColor');\n\nexport const buttonColor = fromState('buttonColor');\n\nexport const buttonTextColor = fromState('buttonTextColor');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottomBarBgColor');\n\nexport const destructiveTextColor = fromState('destructiveTextColor');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('headerBgColor');\n\nexport const hintColor = fromState('hintColor');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const { bgColor } = _state();\n  return !bgColor || isColorDark(bgColor);\n});\n\nexport const linkColor = fromState('linkColor');\n\nexport const secondaryBackgroundColor = fromState('secondaryBgColor');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('sectionBgColor');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('sectionHeaderTextColor');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('sectionSeparatorColor');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitleTextColor');\n\nexport const textColor = fromState('textColor');\n","import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_request_theme', 'theme_changed', options).then(d => d.theme_params);\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}","import type { Computed } from '@telegram-apps/signals';\nimport { isRGB } from '@telegram-apps/transformers';\nimport type { BackgroundColor, BottomBarColor } from '@telegram-apps/bridge';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  backgroundColor as themeBgColor,\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  bottomBarBgColor as themeBottomBarBgColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { HeaderColor, State } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nfunction rgbBasedOn(signal: Computed<'bg_color' | 'secondary_bg_color' | RGB>) {\n  return createComputed<RGB | undefined>(() => {\n    const color = signal();\n\n    return isRGB(color) ? color : color === 'bg_color'\n      ? themeBgColor()\n      : themeSecondaryBgColor();\n  });\n}\n\n/**\n * The Mini App background color.\n */\nexport const [_backgroundColor, backgroundColor] =\n  createSignalsTuple<BackgroundColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] =\n  createSignalsTuple<BottomBarColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    : color === 'bottom_bar_bg_color'\n      // Following the logic from the Telegram SDK.\n      // I removed \"|| '#ffffff'\" because this seems too strange to me. This is just not right.\n      ? themeBottomBarBgColor() || themeSecondaryBgColor()\n      : color === 'secondary_bg_color'\n        ? themeSecondaryBgColor()\n        : themeBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<HeaderColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n","import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type BottomBarColor,\n  type BackgroundColor,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { version, postEvent } from '@/globals.js';\nimport { mount as mountThemeParams } from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { GetCssVarNameFn, HeaderColor, State } from './types.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport { RGB } from '@telegram-apps/types';\n\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: BackgroundColor): void => {\n    if (color !== _backgroundColor()) {\n      postEvent(SET_BG_COLOR_METHOD, { color });\n      _backgroundColor.set(color);\n      saveState();\n    }\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: BottomBarColor) => {\n    if (color !== _bottomBarColor()) {\n      postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color });\n      _bottomBarColor.set(color);\n      saveState();\n    }\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: HeaderColor): void => {\n    if (color !== _headerColor()) {\n      postEvent(SET_HEADER_COLOR_METHOD, isRGB(color) ? { color } : { color_key: color });\n      _headerColor.set(color);\n      saveState();\n    }\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  _isMounted.set(false);\n}\n","import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}","import { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { OpenOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn((options: OpenOptions) => {\n  return request(OPEN_METHOD, 'popup_closed', {\n    ...options,\n    params: prepareParams(options),\n  }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n}, 'A popup is already opened');\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;","import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n","import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion","import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);","import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n","import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n","import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n","import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;","import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);","import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;","import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);","import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n","import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;","import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n  };\n  auth_date: Date;\n  hash: string;\n}\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContact> {\n  const data = await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  });\n\n  return parse(\n    pipe(\n      // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n      union([string(), instance(URLSearchParams)]),\n      transformQueryUsing(\n        looseObject({\n          contact: pipe(\n            string(),\n            jsonParse(),\n            looseObject({\n              user_id: number(),\n              phone_number: string(),\n              first_name: string(),\n              last_name: optional(string()),\n            }),\n          ),\n          auth_date: pipe(\n            string(),\n            transform(input => new Date(Number(input) * 1000)),\n            date(),\n          ),\n          hash: string(),\n        }),\n      ),\n    ),\n    data,\n  );\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return new AbortablePromise<RequestedContact>(async (res, _, context) => {\n      // First of all, let's try to get the requested contact. Probably, we already requested it\n      // before.\n      try {\n        return res(await getRequestedContact(context));\n      } catch (e) {\n        if (e instanceof ValiError) {\n          throw e;\n        }\n      }\n\n      // Then, request access to the user's phone.\n      const status = await requestPhoneAccess(context);\n      if (status !== 'sent') {\n        throw new AccessDeniedError('User denied access');\n      }\n\n      // Time to wait before executing the next request.\n      let sleepTime = 50;\n\n      // We are trying to retrieve the requested contact until the deadline was reached.\n      while (!context.isAborted()) {\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Sleep for some time.\n        await sleep(sleepTime);\n\n        // Increase the sleep time not to kill the backend service.\n        sleepTime += 50;\n      }\n    }, options);\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe('requestContact', fn, {\n  isSupported: 'web_app_request_phone',\n});\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;","import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n","import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);","import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { launchParams, postEvent } from '@/globals.js';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent('web_app_data_send', { data });\n  },\n  {\n    isSupported() {\n      return launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    },\n  },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);","import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n);\n","export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logInfo } from '@/debug.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logInfo(false, 'Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logInfo(false, 'The package was initialized');\n\n  return cleanup;\n}"],"names":["Ee","t","st","e","it","n","r","A","s","a","u","o","p","w","at","ot","Z","D","ke","z","X","v","l","T","G","B","k","xe","F","$e","Pe","Se","ut","ct","ce","pt","je","lt","cn","ft","pn","Ae","pe","dt","le","qe","K","f","j","I","tt","y","b","P","et","S","ie","R","ae","oe","ue","_t","yt","Y","Me","Te","bt","ht","mt","Le","gt","vt","m","g","Ie","wt","Et","We","De","x","Re","kt","L","Ne","Ce","V","q","ee","_","Ue","d","fe","Oe","Je","ze","$","xt","$t","H","te","Ge","Pt","ne","re","St","Be","de","Tt","jt","At","qt","Mt","Lt","It","Wt","O","_e","Dt","Fe","Rt","Ke","Ye","Nt","Ct","He","Ut","Ot","i","c","ye","W","se","Jt","be","zt","Qe","Bt","Gt","he","Ft","Kt","Yt","M","Ht","ln","Qt","fn","Zt","Xt","dn","Vt","_n","en","yn","tn","bn","nn","rn","sn","J","Q","Ze","Xe","me","ge","Ve","an","hn","mn","gn","on","ve","un","h","we","vn","wn","C","createSignal","initialValue","options","signal","createComputed","computed","createSignalsTuple","debug","logInfo","logError","createLogger","setDebug","value","setBridgeDebug","$lastRequestId","$postEvent","_postEvent","_launchParams","launchParams","version","configure","postEvent","lp","retrieveLaunchParams","createPostEvent","createRequestId","invokeCustomMethod","method","params","_invokeCustomMethod","request","eventOrEvents","_request","createIsSupported","supports","proxyMessage","message","CSSVarsBoundError","isCSSVarsBoundError","errorClass","NotAvailableError","isNotAvailableError","InvalidEnvError","isInvalidEnvError","FunctionUnavailableError","isFunctionNotAvailableError","InvalidArgumentsError","isInvalidArguments","cause","ConcurrentCallError","isConcurrentCallError","SetEmojiStatusError","isSetEmojiStatusError","error","AccessDeniedError","isAccessDeniedError","FullscreenFailedError","isFullscreenFailedError","isSSR","wrapSafe","optionsIsSupported","isMounted","isMounting","component","optionSupports","functionId","isSupported","supportsOption","option","tuple","supportError","getError","item","isSupportedItems","errors","supportsOptionError","args","supportsMap","$isSupported","$isInitialized","$isMounted","$isAvailable","isTMA","errMessagePrefix","supportErr","supportsOptionErr","createWrapSafe","overrideIsSupported","createWrapComplete","createWrapSupported","SETUP_METHOD_NAME","CLICK_EVENT_NAME","COMPONENT_NAME","_isVisible","isVisible","_isMounted","wrapComplete","wrapSupported","hide","setVisibility","mount","isPageReload","getStorageValue","setStorageValue","onClick","offClick","off","show","unmount","E","defineNonConcurrentFn","errorMessage","optionsPromise","optionsError","_promise","promise","_error","err","AbortablePromise","batch","defineMountFn","onMounted","rest","data","createWrapBasic","_state","state","isAvailable","METHOD_NAME","requestBiometry","ignoreCanceled","isCancelledError","signalCancel","REQUEST_AUTH_METHOD","INFO_RECEIVED_EVENT","onBiometryInfoReceived","setState","eventToState","throwNotAvailable","event","available","tokenSaved","deviceId","accessRequested","type","accessGranted","mountFn","tMountPromise","tMountError","tIsMounted","abortSignal","wrapBasic","mountPromise","mountError","authFn","tAuthPromise","tAuthError","context","token","authenticate","authPromise","isAuthenticating","authError","openSettings","requestAccessFn","tRequestAccessPromise","tRequestAccessError","requestAccess","requestAccessPromise","isRequestingAccess","requestAccessError","updateToken","createWrapMounted","_isConfirmationEnabled","isConfirmationEnabled","wrapMounted","disableConfirmation","setClosingConfirmation","enableConfirmation","store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_a","_stringify","input","_b","_addIssue","label","dataset","other","expected","received","issue","isSchema","_getStandardProps","value2","_isValidObjectKey","object2","key","_joinExpects","values","separator","list","ValiError","issues","check","requirement","integer","transform","operation","getDefault","schema","array","itemDataset","pathItem","date","instance","class_","looseObject","entries","valueSchema","valueDataset","number","optional","wrapped","default_","record","entryKey","entryValue","keyDataset","string","_subIssues","datasets","union","validDataset","typedDatasets","untypedDatasets","optionDataset","parse","pipe","pipe2","INVOKE_METHOD_NAME","deleteItem","keyOrKeys","keys","_getItem","getItem","getKeys","setItem","clear","HAPTIC_METHOD_NAME","impactOccurred","style","notificationOccurred","selectionChanged","fromState","authDate","canSendAfter","canSendAfterDate","authDateValue","canSendAfterValue","chat","chatType","chatInstance","hash","queryId","_raw","raw","receiver","restore","retrieveRawInitData","startParam","user","_open","urlOrSlug","optionsOrType","slug","hostname","pathname","match","tOpenPromise","tOpenError","open","openPromise","isOpened","openError","removeUndefined","result","N","U","isColorDark","color","rgb","toRGB","acc","modifier","idx","dec","_isCssVarsBound","isCssVarsBound","accentTextColor","backgroundColor","buttonColor","buttonTextColor","bottomBarBgColor","destructiveTextColor","headerBackgroundColor","hintColor","isDark","bgColor","linkColor","secondaryBackgroundColor","sectionBackgroundColor","sectionHeaderTextColor","sectionSeparatorColor","subtitleTextColor","textColor","internalState","hasShineEffect","isEnabled","isLoaderVisible","text","prev","setParams","updates","setCssVar","name","deleteCssVar","THEME_CHANGED_EVENT","onThemeChanged","bindCssVars","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","rgbBasedOn","isRGB","themeBgColor","themeSecondaryBgColor","_backgroundColor","backgroundColorRGB","_bottomBarColor","bottomBarColor","bottomBarColorRGB","themeBottomBarBgColor","_headerColor","headerColor","headerColorRGB","_isActive","isActive","SET_BG_COLOR_METHOD","SET_BOTTOM_BAR_COLOR_METHOD","SET_HEADER_COLOR_METHOD","VISIBILITY_CHANGED_EVENT","isSupportedSchema","onVisibilityChanged","saveState","mountThemeParams","setBackgroundColor","setBottomBarColor","setHeaderColor","addCleanup","cleanup","createCbCollector","bind","cssVar","update","camelToKebab","close","returnBack","ready","prepareParams","title","buttons","id","OPEN_METHOD","buttonId","CLOSE_METHOD","CLOSED_EVENT","TEXT_RECEIVED_EVENT","onCaptured","capture","ManualPromise","openFn","position","_isVerticalEnabled","isVerticalEnabled","disableVertical","setVerticalEnabled","enableVertical","force","FS_CHANGED_EVENT","SA_CHANGED_EVENT","CSA_CHANGED_EVENT","VIEWPORT_CHANGED_EVENT","initialInsets","nonNegative","signalFromState","height","stableHeight","width","isExpanded","isStable","getStateFromStorage","fromCsaState","contentSafeAreaInsets","contentSafeAreaInsetBottom","contentSafeAreaInsetLeft","contentSafeAreaInsetRight","contentSafeAreaInsetTop","fromSaState","safeAreaInsets","safeAreaInsetBottom","safeAreaInsetLeft","safeAreaInsetRight","safeAreaInsetTop","REQUEST_SA_METHOD_NAME","requestContentSafeAreaInsets","requestViewport","requestSafeAreaInsets","onViewportChanged","onFullscreenChanged","onSafeAreaChanged","onContentSafeAreaChanged","insets","shared","settings","setting","expand","REQUEST_METHOD_NAME","isFullscreen","_changeFullscreenPromise","changeFullscreenPromise","_changeFullscreenError","changeFullscreenError","createFullscreenFn","isRequest","requestFullscreen","exitFullscreen","METHOD","tPromise","tError","requestEmojiStatusAccess","requestEmojiStatusAccessPromise","isRequestingEmojiStatusAccess","requestEmojiStatusAccessError","customEmojiId","setEmojiStatus","setEmojiStatusPromise","isSettingEmojiStatus","setEmojiStatusError","wrapOptions","EVENT_NAME","onAddToHomeScreenFailed","listener","once","offAddToHomeScreenFailed","onAddedToHomeScreen","offAddedToHomeScreen","addToHomeScreen","checkHomeScreenStatus","checkHomeScreenStatusPromise","isCheckingHomeScreenStatus","checkHomeScreenStatusError","openLink","url","OPEN_TG_LINK_METHOD","openTelegramLink","urlString","shareURL","sleep","duration","requestPhoneAccess","requestPhoneAccessPromise","isRequestingPhoneAccess","requestPhoneAccessError","getRequestedContact","transformQueryUsing","jsonParse","res","sleepTime","requestContact","requestContactPromise","isRequestingContact","requestContactError","requestWriteAccess","requestWriteAccessPromise","isRequestingWriteAccess","requestWriteAccessError","getCurrentTime","readTextFromClipboard","reqId","captureSameReq","sendData","size","SHARE_STORY_METHOD","shareStory","mediaUrl","SWITCH_INLINE_QUERY_METHOD","switchInlineQuery","query","chatTypes","safeCall","init","acceptCustomStyles","html"],"mappings":"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","x_google_ignoreList":[8,16,27]}