{"version":3,"file":"index.js","sources":["../../bridge/dist/index.js","../../toolkit/dist/index.js","../../navigation/dist/index.js","../../signals/dist/index.js","../src/signals-registry.ts","../src/debug.ts","../src/globals.ts","../src/scopes/createIsSupported.ts","../../../node_modules/.pnpm/error-kid@0.0.4/node_modules/error-kid/dist/index.js","../src/errors.ts","../src/utils/isSSR.ts","../src/scopes/wrappers/wrapSafe.ts","../src/scopes/wrappers/createWrapSafe.ts","../src/scopes/wrappers/createWrapComplete.ts","../src/scopes/wrappers/createWrapSupported.ts","../src/scopes/components/back-button/back-button.ts","../../../node_modules/.pnpm/better-promises@0.4.0/node_modules/better-promises/dist/index.js","../src/scopes/defineNonConcurrentFn.ts","../src/scopes/defineMountFn.ts","../src/scopes/wrappers/createWrapBasic.ts","../src/scopes/components/biometry/signals.ts","../src/scopes/components/biometry/requestBiometry.ts","../src/utils/ignoreCanceled.ts","../src/scopes/signalCancel.ts","../src/scopes/components/biometry/methods.ts","../src/scopes/wrappers/createWrapMounted.ts","../src/scopes/components/closing-behavior/closing-behavior.ts","../../../node_modules/.pnpm/valibot@1.0.0-beta.14_typescript@5.6.3/node_modules/valibot/dist/index.js","../src/scopes/components/cloud-storage/cloud-storage.ts","../src/scopes/components/haptic-feedback/haptic-feedback.ts","../src/scopes/components/init-data/init-data.ts","../src/scopes/components/invoice/invoice.ts","../src/utils/removeUndefined.ts","../../transformers/dist/index.js","../src/utils/isColorDark.ts","../src/scopes/components/theme-params/signals.ts","../src/scopes/components/main-button/signals.ts","../src/scopes/components/main-button/methods.ts","../src/utils/css-vars.ts","../src/scopes/components/theme-params/methods.ts","../src/scopes/components/mini-app/signals.ts","../src/scopes/components/mini-app/methods.ts","../src/scopes/components/popup/prepareParams.ts","../src/scopes/components/popup/popup.ts","../src/scopes/components/qr-scanner/qr-scanner.ts","../src/scopes/components/secondary-button/signals.ts","../src/scopes/components/secondary-button/methods.ts","../src/scopes/components/settings-button/settings-button.ts","../src/scopes/components/swipe-behavior/swipe-behavior.ts","../src/scopes/components/viewport/const.ts","../src/scopes/components/viewport/wrappers.ts","../src/scopes/components/viewport/signals.ts","../src/scopes/components/viewport/static.ts","../src/scopes/components/viewport/mounting.ts","../src/scopes/components/viewport/css-vars.ts","../src/scopes/components/viewport/expand.ts","../src/scopes/components/viewport/fullscreen.ts","../src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts","../src/scopes/utilities/emoji-status/setEmojiStatus.ts","../src/scopes/utilities/home-screen/add-to-home-screen-failed.ts","../src/scopes/utilities/home-screen/added-to-home-screen.ts","../src/scopes/utilities/home-screen/addToHomeScreen.ts","../src/scopes/utilities/home-screen/checkHomeScreenStatus.ts","../src/scopes/utilities/links/openLink.ts","../src/scopes/utilities/links/openTelegramLink.ts","../src/scopes/utilities/links/shareURL.ts","../src/utils/sleep.ts","../src/scopes/utilities/privacy/requestPhoneAccess.ts","../src/scopes/utilities/privacy/requestContact.ts","../src/scopes/utilities/privacy/requestWriteAccess.ts","../src/scopes/utilities/uncategorized/getCurrentTime.ts","../src/scopes/utilities/uncategorized/readTextFromClipboard.ts","../src/scopes/utilities/uncategorized/sendData.ts","../src/scopes/utilities/uncategorized/shareStory.ts","../src/scopes/utilities/uncategorized/switchInlineQuery.ts","../src/utils/safeCall.ts","../src/init.ts"],"sourcesContent":["var E;\n// @__NO_SIDE_EFFECTS__\nfunction Ee(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? (E == null ? void 0 : E.lang),\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? (E == null ? void 0 : E.abortEarly),\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? (E == null ? void 0 : E.abortPipeEarly)\n  };\n}\nvar N;\n// @__NO_SIDE_EFFECTS__\nfunction nt(t) {\n  return N == null ? void 0 : N.get(t);\n}\nvar C;\n// @__NO_SIDE_EFFECTS__\nfunction rt(t) {\n  return C == null ? void 0 : C.get(t);\n}\nvar U;\n// @__NO_SIDE_EFFECTS__\nfunction st(t, e) {\n  var n;\n  return (n = U == null ? void 0 : U.get(t)) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction it(t) {\n  var n, r;\n  const e = typeof t;\n  return e === \"string\" ? `\"${t}\"` : e === \"number\" || e === \"bigint\" || e === \"boolean\" ? `${t}` : e === \"object\" || e === \"function\" ? (t && ((r = (n = Object.getPrototypeOf(t)) == null ? void 0 : n.constructor) == null ? void 0 : r.name)) ?? \"null\" : e;\n}\nfunction A(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ it(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ st(t.reference, o.lang) ?? (c ? /* @__PURE__ */ rt(o.lang) : null) ?? r.message ?? /* @__PURE__ */ nt(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ Ee());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction at(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\nvar ot = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction Z(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction ke() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: ke,\n    expects: \"any\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: z,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction X(t) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: X,\n    expects: \"Function\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"function\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: v,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      var a;\n      const s = n.value;\n      if (s && typeof s == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in s || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ Z(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (a = n.issues) == null || a.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (A(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ at(s, i) && !(i in this.entries) && (n.value[i] = s[i]);\n      } else\n        A(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: T,\n    expects: `(${t.expects} | null | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return (n.value === null || n.value === void 0) && (this.default !== void 0 && (n.value = /* @__PURE__ */ Z(this, n, r)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction G(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: G,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction B(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: B,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ Z(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: k,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : A(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction xe() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: xe,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction F(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ Ee(n));\n  if (r.issues)\n    throw new ot(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $e(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ w(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction Pe(t) {\n  return /* @__PURE__ */ D(\n    /* @__PURE__ */ v({ TelegramWebviewProxy: /* @__PURE__ */ v({ postEvent: /* @__PURE__ */ X() }) }),\n    t\n  );\n}\nfunction Se() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nvar ut = Object.defineProperty, ct = (t, e, n) => e in t ? ut(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, ce = (t, e, n) => ct(t, typeof e != \"symbol\" ? e + \"\" : e, n);\nfunction pt(t) {\n  return (e) => e instanceof t;\n}\nfunction je(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, pt(n)];\n}\nconst [lt, cn] = je(\"CancelledError\", \"Promise was canceled\"), [ft, pn] = je(\n  \"TimeoutError\",\n  (t, e) => [`Timeout reached: ${t}ms`, { cause: e }]\n), Ae = Symbol(\"Resolved\");\nfunction pe(t) {\n  return Array.isArray(t) && t[0] === Ae;\n}\nfunction dt(t) {\n  return [Ae, t];\n}\nfunction le(t, e) {\n  return t.reject = e.reject, t.abort = e.abort, t;\n}\nlet qe = class K extends Promise {\n  constructor(e, n) {\n    let r, s;\n    super((a, i) => {\n      let u, o;\n      typeof e == \"function\" ? (u = e, o = n) : o = e;\n      const c = [], p = (f) => (...j) => {\n        const I = f(...j);\n        return c.forEach((tt) => tt()), I;\n      }, l = new AbortController(), { signal: y } = l;\n      s = (f) => {\n        !y.aborted && l.abort(f);\n      };\n      const b = () => y.reason, P = (f) => {\n        const j = () => {\n          f(b());\n        };\n        y.addEventListener(\"abort\", j, !0);\n        const I = () => {\n          y.removeEventListener(\"abort\", j, !0);\n        };\n        return c.push(I), I;\n      }, et = p((f) => {\n        a(f), s(dt(f));\n      });\n      r = p((f) => {\n        i(f), s(f);\n      }), o || (o = {});\n      const { abortSignal: S, rejectOnAbort: ie = !0 } = o;\n      if (S)\n        if (S.aborted) {\n          const { reason: f } = S;\n          if (ie)\n            return r(f);\n          s(f);\n        } else {\n          const f = () => {\n            s(S.reason);\n          };\n          S.addEventListener(\"abort\", f), c.push(() => {\n            S.removeEventListener(\"abort\", f);\n          });\n        }\n      ie && P(i);\n      const { timeout: R } = o;\n      if (R) {\n        const f = setTimeout(() => {\n          s(new ft(R));\n        }, R);\n        c.push(() => {\n          clearTimeout(f);\n        });\n      }\n      const ae = () => y.aborted, oe = () => pe(b()), ue = () => {\n        const f = b();\n        return pe(f) ? f[1] : void 0;\n      };\n      try {\n        const f = u && u(et, r, {\n          abortReason: b,\n          abortSignal: y,\n          isAborted: ae,\n          isResolved: oe,\n          onAborted: P,\n          onResolved: (j) => P(() => {\n            oe() && j(ue());\n          }),\n          resolved: ue,\n          throwIfAborted() {\n            if (ae())\n              throw b();\n          }\n        });\n        f instanceof Promise && f.catch(r);\n      } catch (f) {\n        r(f);\n      }\n    }), ce(this, \"abort\"), ce(this, \"reject\"), this.abort = s, this.reject = r;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, n) {\n    return new K(async (r, s, a) => {\n      try {\n        r(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, n);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new K((n, r) => {\n      r(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new lt());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return le(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, n) {\n    return le(super.then(e, n), this);\n  }\n};\nfunction _t(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction yt(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[_t(n)] = r, e), {});\n}\nfunction Y(t) {\n  const e = yt(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(Y) : Y(r));\n  }\n  return e;\n}\nfunction Me(t) {\n  return `tapps/${t}`;\n}\nfunction Te(t, e) {\n  sessionStorage.setItem(Me(t), JSON.stringify(e));\n}\nfunction bt(t) {\n  const e = sessionStorage.getItem(Me(t));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction ht(...t) {\n  const e = t.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((n) => {\n        n();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction mt(t, e) {\n  e || (e = {});\n  const {\n    textColor: n,\n    bgColor: r,\n    shouldLog: s\n  } = e, a = s === void 0 ? !0 : s, i = typeof a == \"boolean\" ? () => a : a;\n  function u(o, c, ...p) {\n    if (c || i()) {\n      const l = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[o](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${t}`,\n        `${l};background-color: lightblue;color:black`,\n        \"\",\n        `${l};${n ? `color:${n};` : \"\"}${r ? `background-color:${r}` : \"\"}`,\n        ...p\n      );\n    }\n  }\n  return [u.bind(void 0, \"log\"), u.bind(void 0, \"error\")];\n}\n// @__NO_SIDE_EFFECTS__\nfunction Le(t) {\n  return {\n    lang: (t == null ? void 0 : t.lang) ?? void 0,\n    message: t == null ? void 0 : t.message,\n    abortEarly: (t == null ? void 0 : t.abortEarly) ?? void 0,\n    abortPipeEarly: (t == null ? void 0 : t.abortPipeEarly) ?? void 0\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction gt(t, e) {\n  var n;\n  return (n = void 0) == null ? void 0 : n.get(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction vt(t) {\n  var e, n;\n  const r = typeof t;\n  return r === \"string\" ? `\"${t}\"` : r === \"number\" || r === \"bigint\" || r === \"boolean\" ? `${t}` : r === \"object\" || r === \"function\" ? (t && ((n = (e = Object.getPrototypeOf(t)) == null ? void 0 : e.constructor) == null ? void 0 : n.name)) ?? \"null\" : r;\n}\nfunction m(t, e, n, r, s) {\n  const a = s && \"input\" in s ? s.input : n.value, i = (s == null ? void 0 : s.expected) ?? t.expects ?? null, u = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ vt(a), o = {\n    kind: t.kind,\n    type: t.type,\n    input: a,\n    expected: i,\n    received: u,\n    message: `Invalid ${e}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, c = t.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? t.message ?? /* @__PURE__ */ gt(t.reference, o.lang) ?? (c ? (o.lang, void 0) : null) ?? r.message ?? (o.lang, void 0);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), c && (n.typed = !1), n.issues ? n.issues.push(o) : n.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction g(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(e) {\n      return t[\"~run\"]({ value: e }, /* @__PURE__ */ Le());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ie(t, e) {\n  return Object.hasOwn(t, e) && e !== \"__proto__\" && e !== \"prototype\" && e !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction wt(t, e) {\n  const n = [...new Set(t)];\n  return n.length > 1 ? `(${n.join(` ${e} `)})` : n[0] ?? \"never\";\n}\nvar Et = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(t) {\n    super(t[0].message), this.name = \"ValiError\", this.issues = t;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction We(t, e) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: We,\n    async: !1,\n    expects: null,\n    requirement: t,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && m(this, \"input\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction De(t) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: De,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: t,\n    \"~run\"(e, n) {\n      return e.typed && !this.requirement(e.value) && m(this, \"integer\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(t) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: x,\n    async: !1,\n    operation: t,\n    \"~run\"(e) {\n      return e.value = this.operation(e.value), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Re(t, e, n) {\n  return typeof t.default == \"function\" ? (\n    // @ts-expect-error\n    t.default(e, n)\n  ) : (\n    // @ts-expect-error\n    t.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction kt(t, e) {\n  return !t[\"~run\"]({ value: e }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction L(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: L,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"boolean\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ne(t) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: Ne,\n    expects: \"Date\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return e.value instanceof Date ? isNaN(e.value) ? m(this, \"type\", e, n, {\n        received: '\"Invalid Date\"'\n      }) : e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ce(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: Ce,\n    expects: t.name,\n    async: !1,\n    class: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof this.class ? n.typed = !0 : m(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(t) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: V,\n    expects: \"unknown\",\n    async: !1,\n    getter: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return this.getter(e.value)[\"~run\"](e, n);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: q,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      var s;\n      const a = n.value;\n      if (a && typeof a == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in this.entries) {\n          const u = this.entries[i];\n          if (i in a || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && // @ts-expect-error\n          u.default !== void 0) {\n            const o = i in a ? (\n              // @ts-expect-error\n              a[i]\n            ) : /* @__PURE__ */ Re(u), c = u[\"~run\"]({ value: o }, r);\n            if (c.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: a,\n                key: i,\n                value: o\n              };\n              for (const l of c.issues)\n                l.path ? l.path.unshift(p) : l.path = [p], (s = n.issues) == null || s.push(l);\n              if (n.issues || (n.issues = c.issues), r.abortEarly) {\n                n.typed = !1;\n                break;\n              }\n            }\n            c.typed || (n.typed = !1), n.value[i] = c.value;\n          } else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (m(this, \"key\", n, r, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: a,\n                key: i,\n                // @ts-expect-error\n                value: a[i]\n              }\n            ]\n          }), r.abortEarly))\n            break;\n        }\n        if (!n.issues || !r.abortEarly)\n          for (const i in a)\n            /* @__PURE__ */ Ie(a, i) && !(i in this.entries) && (n.value[i] = a[i]);\n      } else\n        m(this, \"type\", n, r);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction ee(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: ee,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"number\" && !isNaN(e.value) ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: _,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      return n.value === void 0 && (this.default !== void 0 && (n.value = /* @__PURE__ */ Re(this, n, r)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Ue(t, e, n) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: Ue,\n    expects: \"Object\",\n    async: !1,\n    key: t,\n    value: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(r, s) {\n      var a, i;\n      const u = r.value;\n      if (u && typeof u == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ Ie(u, o)) {\n            const c = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of p.issues)\n                b.path = [y], (a = r.issues) == null || a.push(b);\n              if (r.issues || (r.issues = p.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            const l = this.value[\"~run\"](\n              { value: c },\n              s\n            );\n            if (l.issues) {\n              const y = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: c\n              };\n              for (const b of l.issues)\n                b.path ? b.path.unshift(y) : b.path = [y], (i = r.issues) == null || i.push(b);\n              if (r.issues || (r.issues = l.issues), s.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !l.typed) && (r.typed = !1), p.typed && (r.value[p.value] = l.value);\n          }\n      } else\n        m(this, \"type\", r, s);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: d,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      return typeof e.value == \"string\" ? e.typed = !0 : m(this, \"type\", e, n), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction fe(t) {\n  let e;\n  if (t)\n    for (const n of t)\n      e ? e.push(...n.issues) : e = n.issues;\n  return e;\n}\n// @__NO_SIDE_EFFECTS__\nfunction Oe(t, e) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: Oe,\n    expects: /* @__PURE__ */ wt(\n      t.map((n) => n.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, r) {\n      let s, a, i;\n      for (const u of this.options) {\n        const o = u[\"~run\"]({ value: n.value }, r);\n        if (o.typed)\n          if (o.issues)\n            a ? a.push(o) : a = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (a) {\n        if (a.length === 1)\n          return a[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ fe(a)\n        }), n.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        m(this, \"type\", n, r, {\n          issues: /* @__PURE__ */ fe(i)\n        });\n      }\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Je() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: Je,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(t) {\n      return t.typed = !0, t;\n    }\n  };\n}\nfunction ze(t, e, n) {\n  const r = t[\"~run\"]({ value: e }, /* @__PURE__ */ Le(n));\n  if (r.issues)\n    throw new Et(r.issues);\n  return r.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(...t) {\n  return {\n    ...t[0],\n    pipe: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, n) {\n      for (const r of t)\n        if (r.kind !== \"metadata\") {\n          if (e.issues && (r.kind === \"schema\" || r.kind === \"transformation\")) {\n            e.typed = !1;\n            break;\n          }\n          (!e.issues || !n.abortEarly && !n.abortPipeEarly) && (e = r[\"~run\"](e, n));\n        }\n      return e;\n    }\n  };\n}\nfunction xt(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction $t(t) {\n  return Object.entries(t).reduce((e, [n, r]) => (e[xt(n)] = r, e), {});\n}\nfunction H(t) {\n  const e = $t(t);\n  for (const n in e) {\n    const r = e[n];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[n] = Array.isArray(r) ? r.map(H) : H(r));\n  }\n  return e;\n}\nfunction te(t) {\n  return /* @__PURE__ */ x((e) => t ? H(e) : e);\n}\nfunction Ge(t) {\n  return (e) => /* @__PURE__ */ $(\n    t,\n    te(e)\n  );\n}\nfunction Pt(t) {\n  return (e, n) => ze(\n    /* @__PURE__ */ $(t, te(n)),\n    e\n  );\n}\nfunction ne() {\n  return /* @__PURE__ */ x(JSON.parse);\n}\nfunction re(t) {\n  const e = Ge(t);\n  return (n) => /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    ne(),\n    e(n)\n  );\n}\nfunction St(t) {\n  return /* @__PURE__ */ x((e) => {\n    const n = {};\n    return new URLSearchParams(e).forEach((r, s) => {\n      const a = n[s];\n      Array.isArray(a) ? a.push(r) : a === void 0 ? n[s] = r : n[s] = [a, r];\n    }), ze(t, n);\n  });\n}\nfunction Be(t) {\n  return (e) => /* @__PURE__ */ $(\n    /* @__PURE__ */ Oe([/* @__PURE__ */ d(), /* @__PURE__ */ Ce(URLSearchParams)]),\n    St(t),\n    te(e)\n  );\n}\nconst de = /* @__PURE__ */ _(/* @__PURE__ */ V(() => Tt())), jt = /* @__PURE__ */ q({\n  id: /* @__PURE__ */ ee(),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  type: /* @__PURE__ */ d(),\n  title: /* @__PURE__ */ d(),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), At = /* @__PURE__ */ q({\n  added_to_attachment_menu: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  allows_write_to_pm: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  first_name: /* @__PURE__ */ d(),\n  id: /* @__PURE__ */ ee(),\n  is_bot: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  is_premium: /* @__PURE__ */ _(/* @__PURE__ */ L()),\n  last_name: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  language_code: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  photo_url: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  username: /* @__PURE__ */ _(/* @__PURE__ */ d())\n}), qt = /* @__PURE__ */ q({\n  auth_date: /* @__PURE__ */ $(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ x((t) => new Date(Number(t) * 1e3)),\n    /* @__PURE__ */ Ne()\n  ),\n  can_send_after: /* @__PURE__ */ _(/* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x(Number), /* @__PURE__ */ De())),\n  chat: /* @__PURE__ */ _(/* @__PURE__ */ V(() => Mt())),\n  chat_type: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  chat_instance: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  hash: /* @__PURE__ */ d(),\n  query_id: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  receiver: de,\n  start_param: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  signature: /* @__PURE__ */ d(),\n  user: de\n}), Mt = re(jt), Tt = re(At), Lt = Be(qt);\nfunction It(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nconst Wt = Ge(\n  /* @__PURE__ */ Ue(\n    /* @__PURE__ */ d(),\n    /* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ We(It), /* @__PURE__ */ x((t) => t))\n  )\n), O = /* @__PURE__ */ _(\n  /* @__PURE__ */ $(/* @__PURE__ */ d(), /* @__PURE__ */ x((t) => t === \"1\"))\n), _e = re(Wt()), Dt = /* @__PURE__ */ q({\n  tgWebAppBotInline: O,\n  tgWebAppData: /* @__PURE__ */ _(Lt()),\n  tgWebAppDefaultColors: /* @__PURE__ */ _(_e()),\n  tgWebAppFullscreen: O,\n  tgWebAppPlatform: /* @__PURE__ */ d(),\n  tgWebAppShowSettings: O,\n  tgWebAppStartParam: /* @__PURE__ */ _(/* @__PURE__ */ d()),\n  tgWebAppThemeParams: _e(),\n  tgWebAppVersion: /* @__PURE__ */ d()\n}), Fe = Be(Dt), Rt = Pt(Fe()), Ke = /* @__PURE__ */ q({\n  eventType: /* @__PURE__ */ d(),\n  eventData: /* @__PURE__ */ _(/* @__PURE__ */ Je())\n});\nfunction Ye(t, e) {\n  return e || (e = (n, r) => JSON.stringify(r)), new URLSearchParams(\n    Object.entries(t).reduce((n, [r, s]) => (Array.isArray(s) ? n.push(...s.map((a) => [r, String(a)])) : s != null && n.push([\n      r,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : e(r, s)\n    ]), n), [])\n  ).toString();\n}\nfunction Nt(t) {\n  return Ye(t);\n}\nfunction Ct(t) {\n  return Ye(t, (e, n) => e === \"tgWebAppData\" ? Nt(n) : JSON.stringify(n));\n}\nfunction He(t) {\n  try {\n    return /* @__PURE__ */ kt(Fe(), t);\n  } catch {\n    return !1;\n  }\n}\nfunction Ut(t) {\n  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, n) {\n    var r = t.get(e);\n    r ? r.push(n) : t.set(e, [n]);\n  }, off: function(e, n) {\n    var r = t.get(e);\n    r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : t.set(e, []));\n  }, emit: function(e, n) {\n    var r = t.get(e);\n    r && r.slice().map(function(s) {\n      s(n);\n    }), (r = t.get(\"*\")) && r.slice().map(function(s) {\n      s(e, n);\n    });\n  } };\n}\nfunction Ot(t, e) {\n  const n = Ut(), r = /* @__PURE__ */ new Map(), s = (a, i, u) => {\n    u || (u = !1);\n    const o = r.get(a) || /* @__PURE__ */ new Map();\n    r.set(a, o);\n    const c = o.get(i) || [];\n    o.set(i, c);\n    const p = c.findIndex((l) => l[1] === u);\n    p >= 0 && (n.off(a, c[p][0]), c.splice(p, 1), !c.length && o.delete(i), o.size || (r.delete(a), !r.size && e()));\n  };\n  return [\n    function(i, u, o) {\n      !r.size && t();\n      function c() {\n        s(i, u, o);\n      }\n      function p(...b) {\n        o && c(), i === \"*\" ? u(b) : u(...b);\n      }\n      n.on(i, p);\n      const l = r.get(i) || /* @__PURE__ */ new Map();\n      r.set(i, l);\n      const y = l.get(u) || [];\n      return l.set(u, y), y.push([p, o || !1]), c;\n    },\n    s,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    n.emit,\n    function() {\n      const i = n.all.size;\n      n.all.clear(), r.clear(), i && e();\n    }\n  ];\n}\nfunction ye(t, e) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: t, eventData: e }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nlet W = !1;\nconst [se, Jt] = /* @__PURE__ */ mt(\"Bridge\", {\n  bgColor: \"#9147ff\",\n  textColor: \"white\",\n  shouldLog() {\n    return W;\n  }\n}), be = (t) => {\n  se(!1, \"Event received:\", t);\n};\nfunction zt(t) {\n  t !== W && (W = t, W ? Qe(\"*\", be) : Bt(\"*\", be));\n}\nconst Gt = {\n  clipboard_text_received: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    data: /* @__PURE__ */ T(/* @__PURE__ */ k())\n  }),\n  custom_method_invoked: /* @__PURE__ */ v({\n    req_id: /* @__PURE__ */ k(),\n    result: /* @__PURE__ */ B(/* @__PURE__ */ xe()),\n    error: /* @__PURE__ */ B(/* @__PURE__ */ k())\n  }),\n  popup_closed: /* @__PURE__ */ T(\n    /* @__PURE__ */ v({ button_id: /* @__PURE__ */ T(/* @__PURE__ */ k(), () => {\n    }) }),\n    {}\n  ),\n  viewport_changed: /* @__PURE__ */ v({\n    height: /* @__PURE__ */ G(),\n    width: /* @__PURE__ */ T(/* @__PURE__ */ G(), () => window.innerWidth),\n    is_state_stable: /* @__PURE__ */ z(),\n    is_expanded: /* @__PURE__ */ z()\n  })\n};\nfunction he(t) {\n  if (t.source !== window.parent)\n    return;\n  let e;\n  try {\n    e = F(/* @__PURE__ */ $e(/* @__PURE__ */ k(), ne(), Ke), t.data);\n  } catch {\n    return;\n  }\n  const { eventType: n, eventData: r } = e, s = Gt[n];\n  try {\n    const a = s ? F(s, r) : r;\n    Ft(n, a);\n  } catch (a) {\n    Jt(\n      !0,\n      [\n        `An error occurred processing the \"${n}\" event from the Telegram application.`,\n        \"Please, file an issue here:\",\n        \"https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose\"\n      ].join(`\n`),\n      e,\n      a\n    );\n  }\n}\nconst [\n  Qe,\n  Bt,\n  Ft,\n  Kt\n] = Ot(\n  () => {\n    const t = window, e = { receiveEvent: ye };\n    t.TelegramGameProxy_receiveEvent = ye, t.TelegramGameProxy = e, t.Telegram = { WebView: e }, window.addEventListener(\"message\", he);\n  },\n  () => {\n    [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((t) => {\n      delete window[t];\n    }), window.removeEventListener(\"message\", he);\n  }\n);\nfunction Yt(t) {\n  return (e) => e instanceof t;\n}\nfunction M(t, e) {\n  e || (e = []);\n  class n extends Error {\n    constructor(...s) {\n      const a = typeof e == \"function\" ? e(...s) : typeof e == \"string\" ? [e] : e || [];\n      super(...a), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, Yt(n)];\n}\nconst [\n  Ht,\n  ln\n] = M(\n  \"MethodUnsupportedError\",\n  (t, e) => [\n    `Method \"${t}\" is unsupported in Mini Apps version ${e}`\n  ]\n), [\n  Qt,\n  fn\n] = M(\n  \"MethodParameterUnsupportedError\",\n  (t, e, n) => [\n    `Parameter \"${e}\" of \"${t}\" method is unsupported in Mini Apps version ${n}`\n  ]\n), Zt = [\n  \"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\",\n  \"📖 Refer to docs for more information:\",\n  \"https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment\"\n].join(`\n`), [\n  Xt,\n  dn\n] = M(\"LaunchParamsRetrieveError\", Zt), [\n  Vt,\n  _n\n] = M(\"InvalidLaunchParamsError\", (t) => [\n  `Invalid value for launch params: ${t}`\n]), [en, yn] = M(\"UnknownEnvError\"), [\n  tn,\n  bn\n] = M(\n  \"InvokeCustomMethodError\",\n  (t) => [`Server returned error: ${t}`]\n);\nfunction nn(t, e) {\n  e();\n}\n// @__NO_SIDE_EFFECTS__\nfunction rn(t, e) {\n  e || (e = {});\n  const n = e.equals || Object.is;\n  let r = [], s = t;\n  const a = (c) => {\n    if (!n(s, c)) {\n      const p = s;\n      s = c, nn(o, () => {\n        [...r].forEach(([l, y]) => {\n          l(c, p), y && u(l, !0);\n        });\n      });\n    }\n  };\n  function i(c) {\n    const p = typeof c != \"object\" ? { once: c } : c;\n    return {\n      once: p.once || !1,\n      signal: p.signal || !1\n    };\n  }\n  const u = (c, p) => {\n    const l = i(p), y = r.findIndex(([b, P]) => b === c && P.once === l.once && P.signal === l.signal);\n    y >= 0 && r.splice(y, 1);\n  }, o = Object.assign(\n    function() {\n      return sn(o), s;\n    },\n    {\n      destroy() {\n        r = [];\n      },\n      set: a,\n      reset() {\n        a(t);\n      },\n      sub(c, p) {\n        return r.push([c, i(p)]), () => u(c, p);\n      },\n      unsub: u,\n      unsubAll() {\n        r = r.filter((c) => c[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst J = [];\nfunction sn(t) {\n  J.length && J[J.length - 1].add(t);\n}\nconst Q = /* @__PURE__ */ rn(\"https://web.telegram.org\");\nfunction Ze(t, e) {\n  se(!1, \"Posting event:\", e ? { eventType: t, eventData: e } : { eventType: t });\n  const n = window, r = JSON.stringify({ eventType: t, eventData: e });\n  if (Se())\n    return n.parent.postMessage(r, Q());\n  if (Pe(n)) {\n    n.TelegramWebviewProxy.postEvent(t, JSON.stringify(e));\n    return;\n  }\n  if (/* @__PURE__ */ D(/* @__PURE__ */ v({ external: /* @__PURE__ */ v({ notify: /* @__PURE__ */ X() }) }), n)) {\n    n.external.notify(r);\n    return;\n  }\n  throw new en();\n}\nfunction Xe(t, e, n) {\n  n || (n = {});\n  const { capture: r } = n, [s, a] = ht();\n  return new qe((i) => {\n    (Array.isArray(e) ? e : [e]).forEach((u) => {\n      s(\n        Qe(u, (o) => {\n          (!r || (Array.isArray(e) ? r({\n            event: u,\n            payload: o\n          }) : r(o))) && i(o);\n        })\n      );\n    }), (n.postEvent || Ze)(t, n.params);\n  }, n).finally(a);\n}\nconst me = \"launchParams\";\nfunction ge(t) {\n  return t.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\");\n}\nfunction Ve() {\n  for (const t of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    () => ge(window.location.href),\n    // Then, try using the lower level API - window.performance.\n    () => {\n      const e = performance.getEntriesByType(\"navigation\")[0];\n      return e && ge(e.name);\n    },\n    () => bt(me)\n  ]) {\n    const e = t();\n    if (e && He(e))\n      return Te(me, e), e;\n  }\n  throw new Xt();\n}\nfunction an(t) {\n  const e = Rt(Ve());\n  return t ? Y(e) : e;\n}\nfunction hn(t, e) {\n  if (!t)\n    try {\n      return an(), !0;\n    } catch {\n      return !1;\n    }\n  return qe.fn(async (n) => {\n    if (Pe(window))\n      return !0;\n    try {\n      return await Xe(\"web_app_request_theme\", \"theme_changed\", n), !0;\n    } catch {\n      return !1;\n    }\n  }, e || { timeout: 100 });\n}\nfunction mn({ launchParams: t, onEvent: e } = {}) {\n  if (t) {\n    const s = typeof t == \"string\" || t instanceof URLSearchParams ? t.toString() : (\n      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n      // value. We are doing it because we are working with tgWebAppData presented as a\n      // string, not an object as serializeLaunchParamsQuery requires.\n      Ct({ ...t, tgWebAppData: void 0 }) + (t.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(t.tgWebAppData.toString())}` : \"\")\n    );\n    if (!He(s))\n      throw new Vt(s);\n    Te(\"launchParams\", s);\n  }\n  if (Se()) {\n    const s = /* @__PURE__ */ $e(\n      /* @__PURE__ */ k(),\n      ne(),\n      Ke\n    ), a = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (...i) => {\n      const [u] = i, o = () => {\n        a(...i);\n      };\n      if (/* @__PURE__ */ D(s, u) && e) {\n        const c = F(s, u);\n        e([c.eventType, c.eventData], o);\n      } else\n        o();\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy || {}, { postEvent: r } = n;\n  window.TelegramWebviewProxy = {\n    ...n,\n    postEvent(s, a) {\n      const i = () => {\n        r && r(s, a);\n      };\n      e ? e([s, a ? JSON.parse(a) : void 0], i) : i();\n    }\n  }, se(!1, \"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction gn() {\n  return new URLSearchParams(Ve()).get(\"tgWebAppData\") || void 0;\n}\nfunction on(t) {\n  return ({ req_id: e }) => e === t;\n}\nfunction ve(t) {\n  return t.split(\".\").map(Number);\n}\nfunction un(t, e) {\n  const n = ve(t), r = ve(e), s = Math.max(n.length, r.length);\n  for (let a = 0; a < s; a += 1) {\n    const i = n[a] || 0, u = r[a] || 0;\n    if (i !== u)\n      return i > u ? 1 : -1;\n  }\n  return 0;\n}\nfunction h(t, e) {\n  return un(t, e) <= 0;\n}\nfunction we(t, e, n) {\n  if (typeof n == \"string\") {\n    if (t === \"web_app_open_link\") {\n      if (e === \"try_instant_view\")\n        return h(\"6.4\", n);\n      if (e === \"try_browser\")\n        return h(\"7.6\", n);\n    }\n    if (t === \"web_app_set_header_color\" && e === \"color\")\n      return h(\"6.9\", n);\n    if (t === \"web_app_close\" && e === \"return_back\")\n      return h(\"7.6\", n);\n    if (t === \"web_app_setup_main_button\" && e === \"has_shine_effect\")\n      return h(\"7.10\", n);\n  }\n  switch (t) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return h(\"6.1\", e);\n    case \"web_app_open_popup\":\n      return h(\"6.2\", e);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return h(\"6.4\", e);\n    case \"web_app_switch_inline_query\":\n      return h(\"6.7\", e);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return h(\"6.9\", e);\n    case \"web_app_setup_settings_button\":\n      return h(\"6.10\", e);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return h(\"7.2\", e);\n    case \"web_app_setup_swipe_behavior\":\n      return h(\"7.7\", e);\n    case \"web_app_share_to_story\":\n      return h(\"7.8\", e);\n    case \"web_app_setup_secondary_button\":\n    case \"web_app_set_bottom_bar_color\":\n      return h(\"7.10\", e);\n    case \"web_app_request_safe_area\":\n    case \"web_app_request_content_safe_area\":\n    case \"web_app_request_fullscreen\":\n    case \"web_app_exit_fullscreen\":\n    case \"web_app_set_emoji_status\":\n    case \"web_app_add_to_home_screen\":\n    case \"web_app_check_home_screen\":\n    case \"web_app_request_emoji_status_access\":\n    case \"web_app_check_location\":\n    case \"web_app_open_location_settings\":\n    case \"web_app_request_file_download\":\n    case \"web_app_request_location\":\n    case \"web_app_send_prepared_message\":\n    case \"web_app_start_accelerometer\":\n    case \"web_app_start_device_orientation\":\n    case \"web_app_start_gyroscope\":\n    case \"web_app_stop_accelerometer\":\n    case \"web_app_stop_device_orientation\":\n    case \"web_app_stop_gyroscope\":\n    case \"web_app_toggle_orientation_lock\":\n      return h(\"8.0\", e);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(t);\n  }\n}\nfunction vn(t, e) {\n  e || (e = \"strict\");\n  const n = typeof e == \"function\" ? e : (r) => {\n    const { method: s, version: a } = r, i = \"param\" in r ? new Qt(s, r.param, a) : new Ht(s, a);\n    if (e === \"strict\")\n      throw i;\n    return console.warn(i.message);\n  };\n  return (r, s) => we(r, t) ? r === \"web_app_set_header_color\" && /* @__PURE__ */ D(/* @__PURE__ */ v({ color: /* @__PURE__ */ ke() }), s) && !we(r, \"color\", t) ? n({ version: t, method: r, param: \"color\" }) : Ze(r, s) : n({ version: t, method: r });\n}\nfunction wn(t, e, n, r) {\n  return Xe(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n    ...r || {},\n    params: { method: t, params: e, req_id: n },\n    capture: on(n)\n  }).then(({ result: s, error: a }) => {\n    if (a)\n      throw new tn(a);\n    return s;\n  });\n}\nfunction En() {\n  Kt(), zt(!1), Q.unsubAll(), Q.reset();\n}\nexport {\n  Vt as InvalidLaunchParamsError,\n  tn as InvokeCustomMethodError,\n  Xt as LaunchParamsRetrieveError,\n  Qt as MethodParameterUnsupportedError,\n  Ht as MethodUnsupportedError,\n  en as UnknownEnvError,\n  on as captureSameReq,\n  un as compareVersions,\n  vn as createPostEvent,\n  ye as emitEvent,\n  Pe as hasWebviewProxy,\n  wn as invokeCustomMethod,\n  Se as isIframe,\n  _n as isInvalidLaunchParamsError,\n  bn as isInvokeCustomMethodError,\n  dn as isLaunchParamsRetrieveError,\n  fn as isMethodMethodParameterUnsupportedError,\n  ln as isMethodUnsupportedError,\n  hn as isTMA,\n  yn as isUnknownEnvError,\n  mn as mockTelegramEnv,\n  Bt as off,\n  Kt as offAll,\n  Qe as on,\n  Ze as postEvent,\n  Xe as request,\n  En as resetPackageState,\n  an as retrieveLaunchParams,\n  gn as retrieveRawInitData,\n  Ve as retrieveRawLaunchParams,\n  zt as setDebug,\n  we as supports,\n  Q as targetOrigin\n};\n//# sourceMappingURL=index.js.map\n","function C(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction b(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction $(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[b(t)] = n, e), {});\n}\nfunction p(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction m(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[p(t)] = n, e), {});\n}\nfunction s(o) {\n  const e = m(o);\n  for (const t in e) {\n    const n = e[t];\n    n && typeof n == \"object\" && !(n instanceof Date) && (e[t] = Array.isArray(n) ? n.map(s) : s(n));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, t) => `-${t.toLowerCase()}`);\n}\nfunction u(o) {\n  return `tapps/${o}`;\n}\nfunction y(o, e) {\n  sessionStorage.setItem(u(o), JSON.stringify(e));\n}\nfunction S(o) {\n  const e = sessionStorage.getItem(u(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction h(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(o, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: a\n  } = e, r = a === void 0 ? !0 : a, l = typeof r == \"boolean\" ? () => r : r;\n  function c(g, d, ...f) {\n    if (d || l()) {\n      const i = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[g](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${o}`,\n        `${i};background-color: lightblue;color:black`,\n        \"\",\n        `${i};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n        ...f\n      );\n    }\n  }\n  return [c.bind(void 0, \"log\"), c.bind(void 0, \"error\")];\n}\nexport {\n  C as camelToKebab,\n  b as camelToSnake,\n  $ as camelToSnakeObjKeys,\n  h as createCbCollector,\n  T as createLogger,\n  s as deepSnakeToCamelObjKeys,\n  S as getStorageValue,\n  y as setStorageValue,\n  p as snakeToCamel,\n  m as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n","function i() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction c() {\n  const t = i();\n  return !!t && t.type === \"reload\";\n}\nfunction o(t, n) {\n  return t.startsWith(n) ? t : `${n}${t}`;\n}\nfunction R(t) {\n  return new URL(\n    typeof t == \"string\" ? t : [\n      t.pathname || \"\",\n      o(t.search || \"\", \"?\"),\n      o(t.hash || \"\", \"#\")\n    ].join(\"\"),\n    \"http://a\"\n  );\n}\nfunction a(t) {\n  const n = (typeof t == \"string\" ? t : t.pathname || \"\").startsWith(\"/\"), e = R(t), { pathname: s } = e;\n  return `${n ? s : s.slice(1)}${e.search}${e.hash}`;\n}\nconst r = \"ERR_NAVIGATION_HISTORY_EMPTY\", I = \"ERR_NAVIGATION_CURSOR_INVALID\";\nexport {\n  I as ERR_CURSOR_INVALID,\n  r as ERR_HISTORY_EMPTY,\n  R as createSafeURL,\n  o as ensurePrefix,\n  i as getFirstNavigationEntry,\n  c as isPageReload,\n  a as urlToPath\n};\n//# sourceMappingURL=index.js.map\n","let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n","import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}","import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nlet debug = false;\n\nexport const [logInfo, logError] = createLogger('SDK', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n});\n\n/**\n * Sets the package debug mode leading to outputting additional logs.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}","import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logInfo } from '@/debug.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   *\n   * Passing the \"strict\" value creates a function, which always checks if specified call supported\n   * by currently supported Mini Apps version. If the method is unsupported, an error will be\n   * thrown.\n   *\n   * Passing the \"non-strict\" value creates a postEvent function not throwing any errors, but\n   * warning about a missing method support.\n   *\n   * @default 'strict'\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_launchParams, launchParams] =\n  createSignalsTuple<PackageLaunchParams>({\n    tgWebAppPlatform: 'unknown',\n    tgWebAppVersion: '0.0',\n  });\n\nexport const version = createComputed(() => launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logInfo(false, 'The package was configured. Launch params:', _launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n","import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}","var f = Object.defineProperty;\nvar u = (t, r, n) => r in t ? f(t, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[r] = n;\nvar c = (t, r, n) => u(t, typeof r != \"symbol\" ? r + \"\" : r, n);\nfunction i(t) {\n  return (r) => r instanceof t;\n}\nfunction d(t, r) {\n  r || (r = []);\n  class n extends Error {\n    constructor(...e) {\n      const o = typeof r == \"function\" ? r(...e) : typeof r == \"string\" ? [r] : r || [];\n      super(...o), this.name = t;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: t }), [n, i(n)];\n}\nfunction m(t, r, n) {\n  class s extends d(t, n)[0] {\n    constructor(...a) {\n      super(...a);\n      c(this, \"data\");\n      this.data = r(...a);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: t }), [s, i(s)];\n}\nexport {\n  d as errorClass,\n  m as errorClassWithData,\n  i as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);","/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n","import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n","import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n","import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n","import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","var V = Object.defineProperty;\nvar Y = (n, r, e) => r in n ? V(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e;\nvar y = (n, r, e) => Y(n, typeof r != \"symbol\" ? r + \"\" : r, e);\nfunction $(n) {\n  return (r) => r instanceof n;\n}\nfunction B(n, r) {\n  r || (r = []);\n  class e extends Error {\n    constructor(...o) {\n      const s = typeof r == \"function\" ? r(...o) : typeof r == \"string\" ? [r] : r || [];\n      super(...s), this.name = n;\n    }\n  }\n  return Object.defineProperty(e, \"name\", { value: n }), [e, $(e)];\n}\nconst [k, H] = B(\"CancelledError\", \"Promise was canceled\"), [q, J] = B(\n  \"TimeoutError\",\n  (n, r) => [`Timeout reached: ${n}ms`, { cause: r }]\n), D = Symbol(\"Resolved\");\nfunction S(n) {\n  return Array.isArray(n) && n[0] === D;\n}\nfunction z(n) {\n  return [D, n];\n}\nfunction x(n, r) {\n  return n.reject = r.reject, n.abort = r.abort, n;\n}\nclass w extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let d, u;\n      typeof e == \"function\" ? (d = e, u = c) : u = e;\n      const b = [], j = (t) => (...h) => {\n        const p = t(...h);\n        return b.forEach((P) => P()), p;\n      }, g = new AbortController(), { signal: l } = g;\n      s = (t) => {\n        !l.aborted && g.abort(t);\n      };\n      const v = () => l.reason, E = (t) => {\n        const h = () => {\n          t(v());\n        };\n        l.addEventListener(\"abort\", h, !0);\n        const p = () => {\n          l.removeEventListener(\"abort\", h, !0);\n        };\n        return b.push(p), p;\n      }, F = j((t) => {\n        a(t), s(z(t));\n      });\n      o = j((t) => {\n        i(t), s(t);\n      }), u || (u = {});\n      const { abortSignal: f, rejectOnAbort: A = !0 } = u;\n      if (f)\n        if (f.aborted) {\n          const { reason: t } = f;\n          if (A)\n            return o(t);\n          s(t);\n        } else {\n          const t = () => {\n            s(f.reason);\n          };\n          f.addEventListener(\"abort\", t), b.push(() => {\n            f.removeEventListener(\"abort\", t);\n          });\n        }\n      A && E(i);\n      const { timeout: m } = u;\n      if (m) {\n        const t = setTimeout(() => {\n          s(new q(m));\n        }, m);\n        b.push(() => {\n          clearTimeout(t);\n        });\n      }\n      const L = () => l.aborted, T = () => S(v()), C = () => {\n        const t = v();\n        return S(t) ? t[1] : void 0;\n      };\n      try {\n        const t = d && d(F, o, {\n          abortReason: v,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: T,\n          onAborted: E,\n          onResolved: (h) => E(() => {\n            T() && h(C());\n          }),\n          resolved: C,\n          throwIfAborted() {\n            if (L())\n              throw v();\n          }\n        });\n        t instanceof Promise && t.catch(o);\n      } catch (t) {\n        o(t);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new w(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new w((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new k());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(n, r) {\n  return n.resolve = r.resolve, n;\n}\nclass R extends w {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, d, u) => {\n      a = i, o && o(i, d, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport {\n  w as AbortablePromise,\n  k as CancelledError,\n  R as ManualPromise,\n  q as TimeoutError,\n  H as isCancelledError,\n  S as isPromiseResolveResult,\n  J as isTimeoutError\n};\n//# sourceMappingURL=index.js.map\n","import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}","import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n","import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;","import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n","import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n","import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}","import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}","import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n","import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","import { AbortablePromise } from 'better-promises';\nimport { array, check, parse, pipe, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      return parse(\n        record(\n          pipe(string(), check(v => keys.includes(v))),\n          string(),\n        ),\n        data,\n      );\n    })\n    : AbortablePromise.resolve(typeof keyOrKeys === 'string' ? '' : {});\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n","import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');","import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}","var b;\n// @__NO_SIDE_EFFECTS__\nfunction G(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar E;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return E == null ? void 0 : E.get(e);\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = P == null ? void 0 : P.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {\n    kind: e.kind,\n    type: e.type,\n    input: u,\n    expected: i,\n    received: l,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n    requirement: e.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: t.lang,\n    abortEarly: t.abortEarly,\n    abortPipeEarly: t.abortPipeEarly\n  }, y = e.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({ value: n }, /* @__PURE__ */ G());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction N(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: W,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction L(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: v,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e, n, r) {\n  return typeof e.default == \"function\" ? (\n    // @ts-expect-error\n    e.default(n, r)\n  ) : (\n    // @ts-expect-error\n    e.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({ value: n }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: U,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: z,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: w,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") && // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ R(l), y = l[\"~run\"]({ value: o }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues)\n                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), t.abortEarly))\n            break;\n        }\n        if (!r.issues || !t.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ N(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else\n        f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: A,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ R(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: J,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ N(u, o)) {\n            const y = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of p.issues)\n                g.path = [S], (i = t.issues) == null || i.push(g);\n              if (t.issues || (t.issues = p.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            const m = this.value[\"~run\"](\n              { value: y },\n              s\n            );\n            if (m.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of m.issues)\n                g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n              if (t.issues || (t.issues = m.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n          }\n      } else\n        f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction C(e) {\n  let n;\n  if (e)\n    for (const r of e)\n      n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: V,\n    expects: /* @__PURE__ */ te(\n      e.map((r) => r.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({ value: r.value }, t);\n        if (o.typed)\n          if (o.issues)\n            u ? u.push(o) : u = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (u) {\n        if (u.length === 1)\n          return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ C(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ C(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({ value: n }, /* @__PURE__ */ G(r));\n  if (t.issues)\n    throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e)\n        if (t.kind !== \"metadata\") {\n          if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n            n.typed = !1;\n            break;\n          }\n          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n        }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction x(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(x) : x(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */ v((n) => e ? x(n) : n);\n}\nfunction M(e) {\n  return (n) => /* @__PURE__ */ d(\n    e,\n    I(n)\n  );\n}\nfunction T(e) {\n  return (n, r) => B(\n    /* @__PURE__ */ d(e, I(r)),\n    n\n  );\n}\nfunction oe() {\n  return /* @__PURE__ */ v(JSON.parse);\n}\nfunction $(e) {\n  const n = M(e);\n  return (r) => /* @__PURE__ */ d(\n    /* @__PURE__ */ a(),\n    oe(),\n    n(r)\n  );\n}\nfunction ce(e) {\n  return /* @__PURE__ */ v((n) => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return (n) => /* @__PURE__ */ d(\n    /* @__PURE__ */ V([/* @__PURE__ */ a(), /* @__PURE__ */ z(URLSearchParams)]),\n    ce(e),\n    I(n)\n  );\n}\nconst O = /* @__PURE__ */ c(/* @__PURE__ */ w(() => he())), le = /* @__PURE__ */ k({\n  id: /* @__PURE__ */ A(),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  type: /* @__PURE__ */ a(),\n  title: /* @__PURE__ */ a(),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), pe = /* @__PURE__ */ k({\n  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  first_name: /* @__PURE__ */ a(),\n  id: /* @__PURE__ */ A(),\n  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), fe = /* @__PURE__ */ k({\n  auth_date: /* @__PURE__ */ d(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ v((e) => new Date(Number(e) * 1e3)),\n    /* @__PURE__ */ U()\n  ),\n  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ d(/* @__PURE__ */ a(), /* @__PURE__ */ v(Number), /* @__PURE__ */ L())),\n  chat: /* @__PURE__ */ c(/* @__PURE__ */ w(() => ye())),\n  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  hash: /* @__PURE__ */ a(),\n  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  receiver: O,\n  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  signature: /* @__PURE__ */ a(),\n  user: O\n}), ye = $(le), he = $(pe), F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n))\n    return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1)\n      t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(\n  /* @__PURE__ */ J(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ d(/* @__PURE__ */ a(), /* @__PURE__ */ W(H), /* @__PURE__ */ v((e) => e))\n  )\n), j = /* @__PURE__ */ c(\n  /* @__PURE__ */ d(/* @__PURE__ */ a(), /* @__PURE__ */ v((e) => e === \"1\"))\n), Q = $(be()), ve = /* @__PURE__ */ k({\n  tgWebAppBotInline: j,\n  tgWebAppData: /* @__PURE__ */ c(F()),\n  tgWebAppDefaultColors: /* @__PURE__ */ c(Q()),\n  tgWebAppFullscreen: j,\n  tgWebAppPlatform: /* @__PURE__ */ a(),\n  tgWebAppShowSettings: j,\n  tgWebAppStartParam: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  tgWebAppThemeParams: Q(),\n  tgWebAppVersion: /* @__PURE__ */ a()\n}), X = K(ve), ke = T(F()), _e = T(X()), Se = /* @__PURE__ */ k({\n  eventType: /* @__PURE__ */ a(),\n  eventData: /* @__PURE__ */ c(/* @__PURE__ */ q())\n});\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(\n    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([\n      t,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)\n    ]), r), [])\n  ).toString();\n}\nfunction de(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? de(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport {\n  le as InitDataChatSchema,\n  fe as InitDataQuerySchema,\n  pe as InitDataUserSchema,\n  ve as LaunchParamsSchema,\n  Se as MiniAppsMessageSchema,\n  I as conditionalSnakeKeys,\n  M as createCamelCaseGen,\n  T as createCamelCaseSchemaParserGen,\n  $ as createJsonCamelCaseGen,\n  K as createQueryCamelCaseGen,\n  ye as initDataChatJson,\n  F as initDataQuery,\n  he as initDataUserJson,\n  De as isLaunchParamsQuery,\n  H as isRGB,\n  me as isRGBShort,\n  oe as jsonParse,\n  X as launchParamsQuery,\n  ke as parseInitDataQuery,\n  _e as parseLaunchParamsQuery,\n  de as serializeInitDataQuery,\n  Ee as serializeLaunchParamsQuery,\n  Y as serializeToQuery,\n  be as themeParams,\n  ge as toRGB,\n  ce as transformQueryUsing\n};\n//# sourceMappingURL=index.js.map\n","import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n","import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accentTextColor');\n\nexport const backgroundColor = fromState('bgColor');\n\nexport const buttonColor = fromState('buttonColor');\n\nexport const buttonTextColor = fromState('buttonTextColor');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottomBarBgColor');\n\nexport const destructiveTextColor = fromState('destructiveTextColor');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('headerBgColor');\n\nexport const hintColor = fromState('hintColor');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const { bgColor } = _state();\n  return !bgColor || isColorDark(bgColor);\n});\n\nexport const linkColor = fromState('linkColor');\n\nexport const secondaryBackgroundColor = fromState('secondaryBgColor');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('sectionBgColor');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('sectionHeaderTextColor');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('sectionSeparatorColor');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitleTextColor');\n\nexport const textColor = fromState('textColor');\n","import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_request_theme', 'theme_changed', options).then(d => d.theme_params);\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}","import type { Computed } from '@telegram-apps/signals';\nimport { isRGB } from '@telegram-apps/transformers';\nimport type { BackgroundColor, BottomBarColor } from '@telegram-apps/bridge';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  backgroundColor as themeBgColor,\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  bottomBarBgColor as themeBottomBarBgColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { HeaderColor, State } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nfunction rgbBasedOn(signal: Computed<'bg_color' | 'secondary_bg_color' | RGB>) {\n  return createComputed<RGB | undefined>(() => {\n    const color = signal();\n\n    return isRGB(color) ? color : color === 'bg_color'\n      ? themeBgColor()\n      : themeSecondaryBgColor();\n  });\n}\n\n/**\n * The Mini App background color.\n */\nexport const [_backgroundColor, backgroundColor] =\n  createSignalsTuple<BackgroundColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] =\n  createSignalsTuple<BottomBarColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    : color === 'bottom_bar_bg_color'\n      // Following the logic from the Telegram SDK.\n      // I removed \"|| '#ffffff'\" because this seems too strange to me. This is just not right.\n      ? themeBottomBarBgColor() || themeSecondaryBgColor()\n      : color === 'secondary_bg_color'\n        ? themeSecondaryBgColor()\n        : themeBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<HeaderColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n","import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type BottomBarColor,\n  type BackgroundColor,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { version, postEvent } from '@/globals.js';\nimport { mount as mountThemeParams } from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { GetCssVarNameFn, HeaderColor, State } from './types.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport { RGB } from '@telegram-apps/types';\n\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: BackgroundColor): void => {\n    if (color !== _backgroundColor()) {\n      postEvent(SET_BG_COLOR_METHOD, { color });\n      _backgroundColor.set(color);\n      saveState();\n    }\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: BottomBarColor) => {\n    if (color !== _bottomBarColor()) {\n      postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color });\n      _bottomBarColor.set(color);\n      saveState();\n    }\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: HeaderColor): void => {\n    if (color !== _headerColor()) {\n      postEvent(SET_HEADER_COLOR_METHOD, isRGB(color) ? { color } : { color_key: color });\n      _headerColor.set(color);\n      saveState();\n    }\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  _isMounted.set(false);\n}\n","import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}","import { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { OpenOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn((options: OpenOptions) => {\n  return request(OPEN_METHOD, 'popup_closed', {\n    ...options,\n    params: prepareParams(options),\n  }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n}, 'A popup is already opened');\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;","import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n","import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion","import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);","import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n","import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n","import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n","import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;","import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);","import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;","import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);","import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n","import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;","import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n  };\n  auth_date: Date;\n  hash: string;\n}\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContact> {\n  const data = await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  });\n\n  return parse(\n    pipe(\n      // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n      union([string(), instance(URLSearchParams)]),\n      transformQueryUsing(\n        looseObject({\n          contact: pipe(\n            string(),\n            jsonParse(),\n            looseObject({\n              user_id: number(),\n              phone_number: string(),\n              first_name: string(),\n              last_name: optional(string()),\n            }),\n          ),\n          auth_date: pipe(\n            string(),\n            transform(input => new Date(Number(input) * 1000)),\n            date(),\n          ),\n          hash: string(),\n        }),\n      ),\n    ),\n    data,\n  );\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return new AbortablePromise<RequestedContact>(async (res, _, context) => {\n      // First of all, let's try to get the requested contact. Probably, we already requested it\n      // before.\n      try {\n        return res(await getRequestedContact(context));\n      } catch (e) {\n        if (e instanceof ValiError) {\n          throw e;\n        }\n      }\n\n      // Then, request access to the user's phone.\n      const status = await requestPhoneAccess(context);\n      if (status !== 'sent') {\n        throw new AccessDeniedError('User denied access');\n      }\n\n      // Time to wait before executing the next request.\n      let sleepTime = 50;\n\n      // We are trying to retrieve the requested contact until the deadline was reached.\n      while (!context.isAborted()) {\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Sleep for some time.\n        await sleep(sleepTime);\n\n        // Increase the sleep time not to kill the backend service.\n        sleepTime += 50;\n      }\n    }, options);\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe('requestContact', fn, {\n  isSupported: 'web_app_request_phone',\n});\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;","import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n","import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);","import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { launchParams, postEvent } from '@/globals.js';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent('web_app_data_send', { data });\n  },\n  {\n    isSupported() {\n      return launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    },\n  },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);","import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n);\n","export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logInfo } from '@/debug.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logInfo(false, 'Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logInfo(false, 'The package was initialized');\n\n  return cleanup;\n}"],"names":["Ee","t","st","e","it","n","r","A","a","i","u","o","w","at","ot","Z","D","ke","z","X","v","s","T","G","B","k","xe","F","$e","Pe","Se","ut","ct","ce","pt","je","lt","cn","ft","pn","Ae","pe","dt","le","qe","K","f","j","I","tt","y","b","P","et","S","ie","R","ae","oe","ue","_t","yt","Y","Me","Te","bt","ht","mt","Le","gt","vt","m","g","Ie","wt","Et","We","De","x","Re","kt","L","Ne","Ce","V","q","ee","_","Ue","d","fe","Oe","Je","ze","$","xt","$t","H","te","Ge","Pt","ne","re","St","Be","de","Tt","jt","At","qt","Mt","Lt","It","Wt","O","_e","Dt","Fe","Rt","Ke","Ye","Nt","Ct","He","Ut","Ot","c","p","l","ye","W","se","Jt","be","zt","Qe","Bt","Gt","he","Ft","Kt","Yt","M","Ht","ln","Qt","fn","Zt","Xt","dn","Vt","_n","en","yn","tn","bn","nn","rn","sn","J","Q","Ze","Xe","me","ge","Ve","an","hn","mn","gn","on","ve","un","h","we","vn","wn","C","createSignal","initialValue","options","signal","createComputed","computed","createSignalsTuple","debug","logInfo","logError","createLogger","setDebug","value","setBridgeDebug","$lastRequestId","$postEvent","_postEvent","_launchParams","launchParams","version","configure","postEvent","lp","retrieveLaunchParams","createPostEvent","createRequestId","invokeCustomMethod","method","params","_invokeCustomMethod","request","eventOrEvents","_request","createIsSupported","supports","proxyMessage","message","CSSVarsBoundError","isCSSVarsBoundError","errorClass","NotAvailableError","isNotAvailableError","InvalidEnvError","isInvalidEnvError","FunctionUnavailableError","isFunctionNotAvailableError","InvalidArgumentsError","isInvalidArguments","cause","ConcurrentCallError","isConcurrentCallError","SetEmojiStatusError","isSetEmojiStatusError","error","AccessDeniedError","isAccessDeniedError","FullscreenFailedError","isFullscreenFailedError","isSSR","wrapSafe","optionsIsSupported","isMounted","isMounting","component","optionSupports","functionId","isSupported","supportsOption","option","tuple","supportError","getError","item","isSupportedItems","errors","supportsOptionError","args","supportsMap","$isSupported","$isInitialized","$isMounted","$isAvailable","isTMA","errMessagePrefix","supportErr","supportsOptionErr","createWrapSafe","overrideIsSupported","createWrapComplete","createWrapSupported","SETUP_METHOD_NAME","CLICK_EVENT_NAME","COMPONENT_NAME","_isVisible","isVisible","_isMounted","wrapComplete","wrapSupported","hide","setVisibility","mount","isPageReload","getStorageValue","setStorageValue","onClick","offClick","off","show","unmount","E","defineNonConcurrentFn","errorMessage","optionsPromise","optionsError","_promise","promise","_error","err","AbortablePromise","batch","defineMountFn","onMounted","rest","data","createWrapBasic","_state","state","isAvailable","METHOD_NAME","requestBiometry","ignoreCanceled","isCancelledError","signalCancel","REQUEST_AUTH_METHOD","INFO_RECEIVED_EVENT","onBiometryInfoReceived","setState","eventToState","throwNotAvailable","event","available","tokenSaved","deviceId","accessRequested","type","accessGranted","mountFn","tMountPromise","tMountError","tIsMounted","abortSignal","wrapBasic","mountPromise","mountError","authFn","tAuthPromise","tAuthError","context","token","authenticate","authPromise","isAuthenticating","authError","openSettings","requestAccessFn","tRequestAccessPromise","tRequestAccessError","requestAccess","requestAccessPromise","isRequestingAccess","requestAccessError","updateToken","createWrapMounted","_isConfirmationEnabled","isConfirmationEnabled","wrapMounted","disableConfirmation","setClosingConfirmation","enableConfirmation","store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_a","_stringify","input","_b","_addIssue","label","dataset","other","expected","received","issue","isSchema","_getStandardProps","value2","_isValidObjectKey","object2","key","_joinExpects","values","separator","list","ValiError","issues","check","requirement","integer","transform","operation","getDefault","schema","array","itemDataset","pathItem","date","instance","class_","looseObject","entries","valueSchema","valueDataset","number","optional","wrapped","default_","record","entryKey","entryValue","keyDataset","string","_subIssues","datasets","union","validDataset","typedDatasets","untypedDatasets","optionDataset","parse","pipe","pipe2","INVOKE_METHOD_NAME","deleteItem","keyOrKeys","keys","_getItem","getItem","getKeys","setItem","clear","HAPTIC_METHOD_NAME","impactOccurred","style","notificationOccurred","selectionChanged","fromState","authDate","canSendAfter","canSendAfterDate","authDateValue","canSendAfterValue","chat","chatType","chatInstance","hash","queryId","_raw","raw","receiver","restore","retrieveRawInitData","startParam","user","_open","urlOrSlug","optionsOrType","slug","hostname","pathname","match","tOpenPromise","tOpenError","open","openPromise","isOpened","openError","removeUndefined","result","N","U","isColorDark","color","rgb","toRGB","acc","modifier","idx","dec","_isCssVarsBound","isCssVarsBound","accentTextColor","backgroundColor","buttonColor","buttonTextColor","bottomBarBgColor","destructiveTextColor","headerBackgroundColor","hintColor","isDark","bgColor","linkColor","secondaryBackgroundColor","sectionBackgroundColor","sectionHeaderTextColor","sectionSeparatorColor","subtitleTextColor","textColor","internalState","hasShineEffect","isEnabled","isLoaderVisible","text","prev","setParams","updates","setCssVar","name","deleteCssVar","THEME_CHANGED_EVENT","onThemeChanged","bindCssVars","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","rgbBasedOn","isRGB","themeBgColor","themeSecondaryBgColor","_backgroundColor","backgroundColorRGB","_bottomBarColor","bottomBarColor","bottomBarColorRGB","themeBottomBarBgColor","_headerColor","headerColor","headerColorRGB","_isActive","isActive","SET_BG_COLOR_METHOD","SET_BOTTOM_BAR_COLOR_METHOD","SET_HEADER_COLOR_METHOD","VISIBILITY_CHANGED_EVENT","isSupportedSchema","onVisibilityChanged","saveState","mountThemeParams","setBackgroundColor","setBottomBarColor","setHeaderColor","addCleanup","cleanup","createCbCollector","bind","cssVar","update","camelToKebab","close","returnBack","ready","prepareParams","title","buttons","id","OPEN_METHOD","buttonId","CLOSE_METHOD","CLOSED_EVENT","TEXT_RECEIVED_EVENT","onCaptured","capture","ManualPromise","openFn","position","_isVerticalEnabled","isVerticalEnabled","disableVertical","setVerticalEnabled","enableVertical","force","FS_CHANGED_EVENT","SA_CHANGED_EVENT","CSA_CHANGED_EVENT","VIEWPORT_CHANGED_EVENT","initialInsets","nonNegative","signalFromState","height","stableHeight","width","isExpanded","isStable","getStateFromStorage","fromCsaState","contentSafeAreaInsets","contentSafeAreaInsetBottom","contentSafeAreaInsetLeft","contentSafeAreaInsetRight","contentSafeAreaInsetTop","fromSaState","safeAreaInsets","safeAreaInsetBottom","safeAreaInsetLeft","safeAreaInsetRight","safeAreaInsetTop","REQUEST_SA_METHOD_NAME","requestContentSafeAreaInsets","requestViewport","requestSafeAreaInsets","onViewportChanged","onFullscreenChanged","onSafeAreaChanged","onContentSafeAreaChanged","insets","shared","settings","setting","expand","REQUEST_METHOD_NAME","isFullscreen","_changeFullscreenPromise","changeFullscreenPromise","_changeFullscreenError","changeFullscreenError","createFullscreenFn","isRequest","requestFullscreen","exitFullscreen","METHOD","tPromise","tError","requestEmojiStatusAccess","requestEmojiStatusAccessPromise","isRequestingEmojiStatusAccess","requestEmojiStatusAccessError","customEmojiId","setEmojiStatus","setEmojiStatusPromise","isSettingEmojiStatus","setEmojiStatusError","wrapOptions","EVENT_NAME","onAddToHomeScreenFailed","listener","once","offAddToHomeScreenFailed","onAddedToHomeScreen","offAddedToHomeScreen","addToHomeScreen","checkHomeScreenStatus","checkHomeScreenStatusPromise","isCheckingHomeScreenStatus","checkHomeScreenStatusError","openLink","url","OPEN_TG_LINK_METHOD","openTelegramLink","urlString","shareURL","sleep","duration","requestPhoneAccess","requestPhoneAccessPromise","isRequestingPhoneAccess","requestPhoneAccessError","getRequestedContact","transformQueryUsing","jsonParse","res","sleepTime","requestContact","requestContactPromise","isRequestingContact","requestContactError","requestWriteAccess","requestWriteAccessPromise","isRequestingWriteAccess","requestWriteAccessError","getCurrentTime","readTextFromClipboard","reqId","captureSameReq","sendData","size","SHARE_STORY_METHOD","shareStory","mediaUrl","SWITCH_INLINE_QUERY_METHOD","switchInlineQuery","query","chatTypes","safeCall","init","acceptCustomStyles","html"],"mappings":"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","x_google_ignoreList":[8,16,27]}